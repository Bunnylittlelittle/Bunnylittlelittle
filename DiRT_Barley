---
title: "DiRT_With_CDS_two_types_statistic_for_One/no_intron_Barley_samtools_depth"
output: html_document
date: "2023-10-16"
Author: Charlotte Sai Fei Zheng
Modified by: Fei Zheng (add t-test for dicistronic transcripts with one intron and without intron. Use CDS instead of gene coordinates)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Setup

```{r}
library(GenomicRanges)
library(GenomicAlignments)
library(GenomicFeatures)
library(rtracklayer)
library(magrittr)
library(plyr)
library(reshape2)
library(tidyverse)
library(biomaRt)
library(Rsamtools)
library(data.table)
library(GeneOverlap)
library(BiocParallel)
library(doParallel)
```
## Step1: fine tRNA-gene combination from reference genome
# construct proper gene list for anaylsis
```{r}
#Fei edited: load reference genome anotation, this can be from anotation file (gff) or from ensemblplants. Change the pathway to your gff file location.
gene.info.from.gff <- read_delim("C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Reference_genome/Hordeum_vulgare.MorexV3_pseudomolecules_assembly.56.gff3/Hordeum_vulgare.MorexV3_pseudomolecules_assembly.56.gff3", delim = "\t", col_names = FALSE) %>% 
    separate(col = X1, into = c("X1", "X2", "X3", "X4", "X5", "X6", "X7", "X8", "X9"), sep = "\t") %>%
  dplyr::select(X1,X4,X5,X9,X7,X3) %>%
  set_colnames(c("gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand", "gene.biotype")) %>%
  mutate(across(2:3, as.numeric)) %>%
  arrange(gene.chr, gene.start)
## Get full gene information, this will be used later to estimate if tRNAs are overlap with UTR
gene.information <- gene.info.from.gff %>%
  filter(gene.biotype == "gene") %>%
  mutate(gene.id = sub(".*;gene_id=", "", gene.id), #gene id can be changed by using gene_id, transcript_id, or protein_id
       gene.id = sub(";.*", "", gene.id)) %>%
  as.data.frame() %>%
  arrange(gene.chr, gene.end)

##if gene.info.from.gff has UTR, then run CDS.info.sorted 
CDS.info.sorted <- gene.info.from.gff %>%
  filter(gene.biotype == "CDS")   #keep the type of annotation that you are interested to explore
CDS.info.sorted <- CDS.info.sorted %>%
  mutate(gene.id = sub(".*protein_id=", "", gene.id))
CDS.info.sorted$gene.id <- sub(".CDS.*", "", CDS.info.sorted$gene.id)
CDS.info.sorted$gene.id <- sub("\\.\\d+$", "", CDS.info.sorted$gene.id)
CDS.info.sorted %>% arrange(gene.chr, gene.start)

#select start and end point for a gene as the start and end of the gene not include the UTR
CDS.start.point <-  CDS.info.sorted %>% dplyr::select("gene.chr", "gene.start", "gene.id", "gene.strand", "gene.biotype") %>% group_by(gene.id) %>% slice_min(n = 1, gene.start)%>% #select the smallest CDS start point for a gene
  arrange(gene.chr, gene.start)
CDS.end.point <-  CDS.info.sorted %>% dplyr::select("gene.chr", "gene.end", "gene.id", "gene.strand", "gene.biotype") %>% group_by(gene.id) %>% slice_max(n = 1, gene.end)%>% #select the largest CDS end point for a gene
  arrange(gene.chr, gene.end)
CDS.start.end.for.gene <- left_join(CDS.start.point, CDS.end.point, by = "gene.id")%>% dplyr::select("gene.chr.x", "gene.start", "gene.end", "gene.id", "gene.strand.x", "gene.biotype.x") %>%
  set_colnames(c("gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand", "gene.biotype")) %>%
  arrange(gene.chr, gene.end) %>%
  unique()
```
# output the gene info for bedtools use
```{r}
write.table(CDS.start.end.for.gene,
           file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Barley_CDS_info.txt",
           quote = FALSE, sep = "\t",
           row.names = FALSE, col.names = FALSE)
```
#get tRNA information
```{r}
# tRNA info from tRNAscan-SE
tRNA.info <- read_delim("C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/HvtRNA.bed", delim = "\t", col_names = FALSE) %>%
  dplyr::select(X1:X4, X6) %>%
  set_colnames(c("tRNA_chr", "tRNA_start", "tRNA_end", "tRNA_id","tRNA_strand")) %>%
  mutate(across(2:3, as.numeric)) %>%
  arrange(tRNA_chr, tRNA_start)

# output the tRNA info for bedtools use
# write.table(tRNA.info,
#            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/HvtRNA_sorted.txt",
#            quote = FALSE, sep = "\t",
#            row.names = FALSE, col.names = FALSE)
```
##  find closeest gene to an tRNA for both behind and after by ```BEDTools``` on Phoenix HPC terminal
#Before start, the genome file might needed. This information can be pull out from any target dataset `bam` file header. This should be done on R studio and upload the 'Vv_genome.txt' into HPC folder 
```{r}
seq.size <- BamFile("E:/Barley/PRJNA910827/SRR22672685_.sorted.bam") %>%  ##load bam file (aligned RNA seq file) from your directory
  seqinfo() %>% 
  as.data.frame() %>% 
  mutate(sequence =rownames(.)) %>% 
  dplyr::select(sequence, seqlengths) %>% 
  arrange(sequence)
  
# #output the genome file for bedtools use
# write.table(seq.size,
#             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Hvgenome.txt",
#             quote = FALSE, sep = "\t",
#             row.names = FALSE, col.names = FALSE)
```

## Find closest gene to an tRNA for both behind and after by BEDTools on Phoenix HPC terminal. 
Using ignore up/down stream (-iu/id) options is to make sure all tRNA can find genes associated with either up or down stream of the tRNA.
# the .txt files are Windows-style CR-LF line endings. use notepad++ Edit>EOL conversion>Unix to fix them or use this code in HPC on every txt files:
awk '{ sub("\r$", ""); print }' VVgenome.txt > VVgenome.txt
# sort the CDS.start.end.for.gene.txt with bedtools

module load BEDTools
bedtools sort -i Barley_CDS_info.txt > Barley_CDS_info.sorted.txt
bedtools closest -id -a HvtRNA_sorted.txt -b Barley_CDS_info.sorted.txt -g Hvgenome.txt -D ref > Barley_closest_tRNA_gene_upS.bed
bedtools closest -iu -a HvtRNA_sorted.txt -b Barley_CDS_info.sorted.txt -g Hvgenome.txt -D ref > Barley_closest_tRNA_gene_downS.bed

## combine two result files from BedTools and sort, then refine info into proper format
```{r}
closest_tRNA_CDS.up <- read.delim("C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Barley_closest_tRNA_gene_upS.bed", header=FALSE)
closest_tRNA_CDS.down <- read.delim("C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Barley_closest_tRNA_gene_downS.bed", header=FALSE)

closest_tRNA_CDS <- rbind(closest_tRNA_CDS.up,closest_tRNA_CDS.down) %>% 
  unique() %>% 
  set_colnames(c("chr", "tRNA.start", "tRNA.end", "tRNA.id", "tRNA.strand",
                 "gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand",
                 "gene.biotype", "distance")) %>%
  dplyr::select(-gene.chr) %>%
  mutate(tRNAFirst = tRNA.start < gene.start,
         tRNA.upstream = ifelse(gene.strand == '+' & distance > 0, TRUE,
                                ifelse(gene.strand == '-' & distance < 0, TRUE, FALSE)),
         interval.length = ifelse(tRNAFirst == TRUE, 
                                  (gene.start-1)-(tRNA.end+1)+1, (tRNA.start-1)-(gene.end+1)+1))
```
## subset proper distance (not overlapped) for tRNA-gene combination and add unique id to them
#This pipeline is designed for non-stranded library, so only non-overlapped tRNA-gene combinations are considered as input. tRNA or gene id stand itself may cause issue for one match many, therefore, unique combination id is created.
```{r}
tRNA.CDS.combo <- closest_tRNA_CDS %>%
  filter(distance != 0, gene.start != -1, interval.length != 0) %>%
  mutate(tRNA.id = as.character(tRNA.id),
         gene.id = as.character(gene.id)) %>% 
  split(f = seq(1, nrow(.))) %>% # break up the dataframe to one col one dataframe 
  lapply(function(x){mutate(x, id = paste(sort(c(x$tRNA.id, x$gene.id)), collapse = "_"))}) %>%
  bind_rows() %>% group_by(gene.id) %>% slice_min(n = 1, interval.length)%>%
    ungroup()
```
# We can try to combine tRNA.CDS.combo with full gene information to see how many tRNA are in UTR.
# Get tRNA coordinates from tRNA.CDS combo, then get full gene coordinates from gene.information. As we delete the tRNA overlap with CDS in tRNA.CDS.combo, then if tRNA overlap with gene.information, then the tRNA is in UTR
```{r}
# estimate if tRNA overlaps with UTR
tRNA.CDS.combo.tRNA.UTR.overlap <- left_join(tRNA.CDS.combo, gene.information, by = "gene.id") %>%
  dplyr::select(chr, tRNA.id, tRNA.start, tRNA.end, tRNA.strand, gene.id, gene.start.y, gene.end.y, gene.strand.x, tRNA.upstream, tRNAFirst, interval.length) %>%  
  mutate(tRNA.overlap.UTR = ifelse(tRNAFirst == 'TRUE' & gene.start.y < tRNA.end, TRUE,
                                    ifelse(tRNAFirst == 'FALSE'& gene.end.y > tRNA.start, "TRUE","FALSE" ))) %>%
  dplyr::select(chr, tRNA.id, tRNA.start, tRNA.end, tRNA.strand, gene.id, gene.start.y, gene.end.y, gene.strand.x,  tRNA.upstream, tRNAFirst, interval.length, tRNA.overlap.UTR)
tRNA.UTR.tgene.combo <- table(tRNA.CDS.combo.tRNA.UTR.overlap$tRNA.overlap.UTR == "TRUE")
#output the tRNA:mRNA combination file
# write.table(tRNA.CDS.combo,
#             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Barley_tRNA.CDS.combo.txt",
#             quote = FALSE, sep = "\t",
#             row.names = FALSE, col.names = FALSE)
```
# filter commonly expressed tRNA and gene 
## setup the bundary for the whole genome (safty net!)
```{r}
Seqinfo <- read_delim("C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/HVgenome.txt", 
                      delim = "\t", col_names = FALSE) %>%
  set_names(c("seqnames", "seqlengths"))

Seqinfo <- with(Seqinfo,
                Seqinfo(seqnames = seqnames,
                        seqlengths = seqlengths,
                        isCircular = rep(FALSE, length(seqnames)),
                        genome = "genomeBuild")) %>%
  sortSeqlevels()
```
## Seperate tRNA information and gene information from tRNA.CDS.combo and make them into bed files
```{r}
tRNA_closest_bed <- tRNA.CDS.combo %>%
  dplyr::select(chr, tRNA.start, tRNA.end, tRNA.id,tRNA.strand)
CDS_closest_bed <- tRNA.CDS.combo %>%
  dplyr::select(chr, gene.start, gene.end, gene.id, gene.strand)
#output tRNA bed files
# write.table(tRNA_closest_bed,
#             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Barley_tRNA_Closest.bed",
#             quote = FALSE, sep = "\t",
#             row.names = FALSE, col.names = FALSE)
```
## Count reads for closest tRNA bed file from your RNA seq bam files 

bedtools multicov -bams SRR22672685_.sorted.bam SRR22672686_.sorted.bam SRR22672687_.sorted.bam -bed Barley_tRNA_Closest.bed > BarleytRNAclosest_count.cnt 

#load tRNA count from bedtools 
```{r}
tRNA_count <- read.delim("E:/Barley/PRJNA910827/BarleytRNAclosest_count.cnt", header=FALSE)
```
## filter commonly expressed tRNA 
```{r}
# filter expressed tRNA 
# filter needs to be defined according to your dataset. Here, the requirement is at least one read align to this tRNA and reads alignment commonly presents at least in 6 samples 
tRNA.expressed.AllSample <- rowSums(dplyr::select(tRNA_count,6:8) >= 1) ==3 
# return logical value for all read count column
sum(tRNA.expressed.AllSample) 
common.tRNA <- tRNA_count[tRNA.expressed.AllSample,] %>%
  set_colnames(c("Chr", "tRNA.start", "tRNA.end", "tRNA.id", "tRNA.strand", "bamfile1", "bamfile2", "bamfile3"))
tRNA.expressed.CDS.combo <- filter(tRNA.CDS.combo, tRNA.id %in% common.tRNA$tRNA.id) 
```
## build up the ```GRange``` by ```makeGRangesFromDataFrame``` for gene
```{r}
# prepare gene data
gene.counts <- tRNA.expressed.CDS.combo %>%
  dplyr::select(chr, gene.start, gene.end, gene.id, gene.strand) %>%
  unique()
# output the tRNA:mRNA combination file
# write.table(gene.counts,
#             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Barley_CDS_Closest.bed",
#             quote = FALSE, sep = "\t",
#             row.names = FALSE, col.names = FALSE)
```
## Count reads for closest tRNA bed file from your RNA seq bam files 

bedtools multicov -bams SRR22672685_.sorted.bam SRR22672686_.sorted.bam SRR22672687_.sorted.bam -bed Barley_CDS_Closest.bed > BarleyCDSclosest_count.cnt 

#load CDS count from bedtools 
```{r}
gene.counts <- read.delim("E:/Barley/PRJNA910827/BarleyCDSclosest_count.cnt", header=FALSE)
```
## filter commonly expressed gene
```{r}
# filter expressed gene 
gene.expressed.AllSample <- rowSums(dplyr::select(gene.counts, 6:8) >= 1) == 3 # same requirement as above 
sum(gene.expressed.AllSample) 
common.gene <- gene.counts[gene.expressed.AllSample,] %>%
  set_colnames(c("Chr", "gene.start", "gene.end", "gene.id", "gene.strand", "bamfile1", "bamfile2", "bamfile3"))
tRNA.CDS.expressed.combo <- filter(tRNA.expressed.CDS.combo, gene.id %in% common.gene$gene.id)
# How many tRNA in UTR
tRNA.in.expressed.UTR <- left_join(tRNA.CDS.expressed.combo, tRNA.CDS.combo.tRNA.UTR.overlap,by = "gene.id") 
tRNA.UTR.tgene.expressed.combo <- table(tRNA.in.expressed.UTR$tRNA.overlap.UTR == "TRUE")
```
####Extract candidates in tRNA.CDS.expressed.combo has no intron or one intron:
#extract exon information from plant ensembl
```{r}
#To choose BioMart database and construct information needed
listMarts(host="https://plants.ensembl.org")
useMart("plants_mart", host="https://plants.ensembl.org") %>% listDatasets()

# Choose data types you want to download
m <- useMart("plants_mart", dataset="hvulgare_eg_gene", host="https://plants.ensembl.org")
attrib <- listAttributes(m) # search any attributes that you think might be useful
```

```{r}
# define input.data
input.data <- tRNA.CDS.expressed.combo
# pull out the exon information from ensembl 
exon.info <- getBM(attributes=c("chromosome_name", "exon_chrom_start", "exon_chrom_end", 
                                "ensembl_exon_id","ensembl_gene_id", "strand"), mart=m) %>%
  set_colnames(c("chr","start","end","exon_UTR_id","gene.id","gene.strand")) %>%
  mutate(gene.strand = ifelse(gene.strand == 1,"+","-"))%>%
  unique() %>%
  separate(col ="exon_UTR_id", sep = "-E", into=c("transcript.id","exon_UTR_id")) %>% mutate("exon_UTR_id" = paste0('exon', exon_UTR_id)) %>%
  dplyr::select(chr, start, end, gene.id, gene.strand, exon_UTR_id) %>%
  set_colnames(c("chr","start","end","gene.id","gene.strand","exon_UTR_id")) %>%
  mutate(across(2:3, as.numeric)) %>%
  arrange(chr, start) %>%
  unique()
#get expressed exon information
tgene.expressed.exon.info <- exon.info %>%
  filter(gene.id %in% input.data$gene.id)
```
#get how many tRNA.gene.expressed.combo have no intron
```{r}
### Fei edited: filter positive result with only 1 exon (no intron)
tgene.expressed.exon2 <- tgene.expressed.exon.info  %>% filter(`exon_UTR_id` == "exon2")
tgene.only.one.exon <- subset(tgene.expressed.exon.info , !(gene.id %in% tgene.expressed.exon2$gene.id))

write.table(tgene.only.one.exon,
            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Result/Barley827_tGene_expressed_no_intron.xlsx",
           quote = FALSE, sep = "\t", row.names = FALSE)

### filter positive result with only 2 exon (one intron)
tgene.expressed.exon3 <- tgene.expressed.exon.info %>% filter(`exon_UTR_id` == "exon3")
tgene.expressed.with1and2exon <- subset(tgene.expressed.exon.info, !(gene.id %in% tgene.expressed.exon3$gene.id)) 
tgene.expressed.with2exon <-  subset(tgene.expressed.with1and2exon, !(gene.id %in% tgene.only.one.exon$gene.id))  %>% filter(`exon_UTR_id` == "exon2")

write.table(tgene.expressed.with2exon,
            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Result/Barley827_tGene_expressed_one_intron.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
```
#get UTR information. The UTR information from gff and ensembl plant are same
```{r}
#===============================================================================#

UTR5.info <- getBM(attributes=c("chromosome_name", "5_utr_start", "5_utr_end",
                                "ensembl_gene_id","ensembl_gene_id", "strand"), mart=m) %>%
  set_colnames(c("chr","start","end","exon_UTR_id","gene.id","gene.strand"))  %>%
  filter(gene.id %in% input.data$gene.id) %>%
  mutate(#chr = paste0('chr', chr),
         gene.strand = ifelse(gene.strand == 1,"+","-"),
         `exon_UTR_id` = paste0(`exon_UTR_id`,".5_UTR")) %>%
  na.omit() %>%
  arrange(chr,start)

# give unique numbers to UTRs that are belongs to same genes
UTR.num <- sapply(as.character(unique(UTR5.info$gene.id)), function(g){
  rowNb <- which(g == UTR5.info$gene.id)
  strand <- UTR5.info$gene.strand[rowNb]
  start <- UTR5.info$start[rowNb]
  order(ifelse(strand =="+", start, -start))
}) %>% unlist()
UTR5.info %<>% mutate(`exon_UTR_id` = paste0(`exon_UTR_id`,".",UTR.num))

#===============================================================================#

UTR3.info <- getBM(attributes=c("chromosome_name", "3_utr_start", "3_utr_end",
                                "ensembl_gene_id","ensembl_gene_id", "strand"), mart=m)%>%
  set_colnames(c("chr","start","end","exon_UTR_id","gene.id","gene.strand")) %>%
  filter(gene.id %in% input.data$gene.id) %>%
  mutate(#chr = paste0('chr', chr),
         gene.strand = ifelse(gene.strand == 1,"+","-"),
         `exon_UTR_id` = paste0(`exon_UTR_id`,".3_UTR")) %>%
  na.omit() %>%
  arrange(chr,start)

UTR.num <- sapply(as.character(unique(UTR3.info$gene.id)), function(g){
  rowNb <- which(g == UTR3.info$gene.id)
  strand <- UTR3.info$gene.strand[rowNb]
  start <- UTR3.info$start[rowNb]
  order(ifelse(strand =="+", start, -start))
}) %>% unlist()
UTR3.info %<>% mutate(`exon_UTR_id` = paste0(`exon_UTR_id`,".",UTR.num))

# bind them all together and sorted
UTR_exon.info <- rbind(tgene.expressed.exon.info,
                       UTR5.info,
                       UTR3.info) %>%
  arrange(chr, start, end)
```
# It looks like the first or last exon embl plants defined acturaly take UTR into a count as a part of it. if UTR info is provided, the intron in the UTR region can be found. otherwise, it returns intron info in the following code as typical intron, which is between two exon is a intron.
```{r}
# pull out intron coordinates based on the data above
UTR_exon.set1 <- tgene.expressed.exon.info %>% 
  dplyr::select(chr,start,end,exon_UTR_id,gene.id, gene.strand) %>%
  set_colnames(c("chr","start.set1","end.set1",
                 "exon_UTR_id.set1","gene.id.set1","gene.strand.set1"))

UTR_exon.set2 <- tgene.expressed.exon.info[-1,] %>% 
  dplyr::select(start,end,exon_UTR_id,gene.id, gene.strand) %>%
  set_colnames(c("start.set2","end.set2",
                 "exon_UTR_id.set2","gene.id.set2","gene.strand.set2")) %>%
  rbind(c(0,0,NA,NA,NA))

intron.info <- cbind(UTR_exon.set1, UTR_exon.set2) %>% #intron.info = tRNA.CDS.expressed.combo - gene candidates without intron (17)
  filter(gene.id.set1 == gene.id.set2 & end.set1 < start.set2) %>%
  dplyr::select(chr, end.set1, start.set2, `exon_UTR_id.set1`, gene.id.set1, gene.strand.set1) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "intron.id","gene.id", "gene.strand")) %>%
  arrange(chr, intron.start) %>%
  mutate(intron.start = intron.start+1,
         intron.end = intron.end-1,
         intron.id = paste0(gene.id, '.intron'))

intron.num <- sapply(as.character(unique(intron.info$gene.id)), function(g){
  rowNb <- which(g == intron.info$gene.id)
  strand <- intron.info$gene.strand[rowNb]
  start <- intron.info$intron.start[rowNb]
  order(ifelse(strand =="+", start, -start))
}) %>% unlist()

intron.info %<>% mutate(intron.id = paste0(intron.id,".", intron.num)) #Candidates without intron will not be included in intron.info
```
# prepare intron coverage data
Here, we had expressed tRNA-gene combination as potential candidates. Now, we need to assess the expression of intron and intergeneic region for each candidates to test if tRNA and gene are co-transcribed.
## Create GRanges to assess the coverage for each sample
### get intergenic and intron1&2 coordinates
```{r}
# keep combination id safe
id <- input.data$id
# get correct intergenic coordinates
intergenic.info <- data_frame(chr = input.data$chr,
                              start = ifelse(input.data$tRNAFirst == TRUE,
                                             input.data$tRNA.end+1,
                                             input.data$gene.end+1),
                              end = ifelse(input.data$tRNAFirst == TRUE,
                                           input.data$gene.start-1,
                                           input.data$tRNA.start-1),
                              strand = rep("NA", nrow(input.data)),
                              ids = input.data$id,
                              gene.id = input.data$gene.id,
                              type = rep("intergenic", nrow(input.data)),
                              gene.strand = input.data$gene.strand,
                              length = end-start+1,
                              sameStrand = input.data$tRNA.strand == input.data$gene.strand,
                              tRNAFirst = input.data$tRNAFirst,
                              tRNA.upstream = input.data$tRNA.upstream)

# get correct intron
# need closest and 2nd closest intron to intergenic
tRNA.up.intergenic <- filter(intergenic.info, 
                             tRNAFirst == TRUE)

tRNA.down.intergenic <- filter(intergenic.info, 
                               tRNAFirst == FALSE)

# corrdinates for closest intron to intergenic for tRNA.up.intergeic 
list.gene.id <- unique(tRNA.up.intergenic$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(intron.info$gene.id == g)
  start <- intron.info$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)

intron.closest.for.stats.up <- intron.info[res,]
intron.closest.for.stats.up <- data_frame(chr = intron.closest.for.stats.up$chr,
                                          start = intron.closest.for.stats.up$intron.start,
                                          end = intron.closest.for.stats.up$intron.end,
                                          strand = intron.closest.for.stats.up$gene.strand,
                                          ids = intron.closest.for.stats.up$intron.id,
                                          gene.id = intron.closest.for.stats.up$gene.id,
                                          type = rep("intron_closest_to_intergenic", nrow(intron.closest.for.stats.up)),
                                          gene.strand = intron.closest.for.stats.up$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(intron.closest.for.stats.up)),
                                          tRNAFirst = rep("NA", nrow(intron.closest.for.stats.up)),
                                          tRNA.upstream = rep("NA", nrow(intron.closest.for.stats.up)))

# range for 2nd closest intron to intergenic 
# if a gene dose not have more than one intron then the intron/intron comprison will be missing
res <- lapply(list.gene.id,function(g){
  rowNb <- which(intron.info$gene.id == g)
  start <- intron.info$intron.start[rowNb]
  or <- order(start)
  c(rowNb[or==2]) 
}) 
res <- unlist(res)

intron.2nd_closest.for.stats.up <- intron.info[res,]
intron.2nd_closest.for.stats.up <- data_frame(chr = intron.2nd_closest.for.stats.up$chr,
                                              start = intron.2nd_closest.for.stats.up$intron.start,
                                              end = intron.2nd_closest.for.stats.up$intron.end,
                                              strand = intron.2nd_closest.for.stats.up$gene.strand,
                                              ids = intron.2nd_closest.for.stats.up$intron.id,
                                              gene.id = intron.2nd_closest.for.stats.up$gene.id,
                                              type = rep("intron_2nd_closest_to_intergenic", nrow(intron.2nd_closest.for.stats.up)),
                                              gene.strand = intron.2nd_closest.for.stats.up$gene.strand,
                                              length = end-start+1,
                                              sameStrand = rep("NA", nrow(intron.2nd_closest.for.stats.up)),
                                              tRNAFirst = rep("NA", nrow(intron.2nd_closest.for.stats.up)),
                                              tRNA.upstream = rep("NA", nrow(intron.2nd_closest.for.stats.up)))

# range for closest intron to intergenic for tRNA.down.intergeic 
list.gene.id <- unique(tRNA.down.intergenic$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(intron.info$gene.id == g)
  start <- intron.info$intron.start[rowNb]
  or <- order(start)
  rowNb[or==max(or)]
}) 
res <- unlist(res)

intron.closest.for.stats.down <- intron.info[res,]
intron.closest.for.stats.down <- data_frame(chr = intron.closest.for.stats.down$chr,
                                            start = intron.closest.for.stats.down$intron.start,
                                            end = intron.closest.for.stats.down$intron.end,
                                            strand = intron.closest.for.stats.down$gene.strand,
                                            ids = intron.closest.for.stats.down$intron.id,
                                            gene.id = intron.closest.for.stats.down$gene.id,
                                            type = rep("intron_closest_to_intergenic", nrow(intron.closest.for.stats.down)),
                                            gene.strand = intron.closest.for.stats.down$gene.strand,
                                            length = end-start+1,
                                            sameStrand = rep("NA", nrow(intron.closest.for.stats.down)),
                                            tRNAFirst = rep("NA", nrow(intron.closest.for.stats.down)),
                                            tRNA.upstream = rep("NA", nrow(intron.closest.for.stats.down)))

# range for 2nd closest intron to intergenic
res <- lapply(list.gene.id,function(g){
  rowNb <- which(intron.info$gene.id == g)
  start <- intron.info$intron.start[rowNb]
  or <- order(start)
  rowNb[or==max(or)-1] 
}) 
res <- unlist(res)

intron.2nd_closest.for.stats.down <- intron.info[res,]
intron.2nd_closest.for.stats.down <- data_frame(chr = intron.2nd_closest.for.stats.down$chr,
                                                start = intron.2nd_closest.for.stats.down$intron.start,
                                                end = intron.2nd_closest.for.stats.down$intron.end,
                                                strand = intron.2nd_closest.for.stats.down$gene.strand,
                                                ids = intron.2nd_closest.for.stats.down$intron.id,
                                                gene.id = intron.2nd_closest.for.stats.down$gene.id,
                                                type = rep("intron_2nd_closest_to_intergenic", nrow(intron.2nd_closest.for.stats.down)),
                                                gene.strand = intron.2nd_closest.for.stats.down$gene.strand,
                                                length = end-start+1,
                                                sameStrand = rep("NA", nrow(intron.2nd_closest.for.stats.down)),
                                                tRNAFirst = rep("NA", nrow(intron.2nd_closest.for.stats.down)),
                                                tRNA.upstream = rep("NA", nrow(intron.2nd_closest.for.stats.down)))

# combine info together for closest and 2nd closest intron
intron.closest <- do.call("rbind", list(intron.closest.for.stats.up,
                                        intron.closest.for.stats.down)) %>% 
  arrange(gene.id) %>% 
  unique()

intron.2nd.closest <- do.call("rbind", list(intron.2nd_closest.for.stats.up,
                                            intron.2nd_closest.for.stats.down)) %>% 
  arrange(gene.id) %>% 
  unique()

# put everything together for calculate average coverage (AC)
intergenic.info %<>% mutate(ids = paste0("intergenic_", ids))

final.stats.info <- do.call("rbind", list(intron.closest,
                                          intron.2nd.closest,
                                          intergenic.info)) %>%
  arrange(gene.id)
```
### Instead of write intron and intergenic info into ``GRange`` object, I will use bedtools multicov to do this. Therefore, I need to create three bed files for them
### When I use SAMtools to calculate the RNA sequence depth, samtool take the position 1 from bed file as postion 0 for a gene, so I need to -1 for the gene start

```{r}
 # intergenic
 intergenic.info.bed <- intergenic.info %>%
   dplyr::select(chr, start, end, ids) %>%
    dplyr::mutate(start = start - 1)
 #output the file
 write.table(intergenic.info.bed,
             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/intergenic_info.bed",
             quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
 
 # Intron1
 intron.closest.info.bed <- intron.closest %>%
   dplyr::select(chr, start, end, ids) %>%
    dplyr::mutate(start = start - 1)
 #output the file
 write.table(intron.closest.info.bed,
             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Intron1_info.bed",
             quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
  # Intron2
 intron.2nd.closest.info.bed <- intron.2nd.closest %>%
   dplyr::select(chr, start, end, ids) %>%
    dplyr::mutate(start = start - 1)
 #output the file
 write.table(intron.2nd.closest.info.bed,
             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Intron2_info.bed",
             quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
```

## Count reads for intergenic, intron 1 and 2 bed file from your RNA seq bam files 
for i in {22672685..22672687}; do
  samtools depth -@ 30 -b intergenic_info.bed -a "SRR${i}_.sorted.bam" > "Cov_SRR${i}_intergenic.txt"
  samtools depth -@ 30 -b Intron1_info.bed -a "SRR${i}_.sorted.bam" > "Cov_SRR${i}_Intron1.txt"
  samtools depth -@ 30 -b Intron2_info.bed -a "SRR${i}_.sorted.bam" > "Cov_SRR${i}_Intron2.txt"
done

##load depth count from SAMtools 
```{r}
#SRR22672685
Intergenic_coverage_SRR22672685 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672685_intergenic.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
Intron1_coverage_SRR22672685 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672685_Intron1.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
Intron2_coverage_SRR22672685 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672685_Intron2.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
#SRR22672686
Intergenic_coverage_SRR22672686 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672686_intergenic.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
Intron1_coverage_SRR22672686 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672686_Intron1.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
Intron2_coverage_SRR22672686 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672686_Intron2.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
#SRR22672687
Intergenic_coverage_SRR22672687 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672687_intergenic.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
Intron1_coverage_SRR22672687 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672687_Intron1.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
Intron2_coverage_SRR22672687 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672687_Intron2.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
```
#summary the depth dataframe, and get 2 dataframe average coverage & number of zero base pairs of intergenic region
```{r}
###Intergenic 
Coverage_intergenic_SRR22672685 <- Intergenic_coverage_SRR22672685 %>%
  left_join(intergenic.info, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_intergenic_SRR22672686 <- Intergenic_coverage_SRR22672686 %>%
  left_join(intergenic.info, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_intergenic_SRR22672687 <- Intergenic_coverage_SRR22672687 %>%
  left_join(intergenic.info, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

#rename the coverage column in each sample with sample name
Coverage_intergenic_SRR22672685 <- Coverage_intergenic_SRR22672685 %>%
  rename(SRR22672685_Cov = coverage)
Coverage_intergenic_SRR22672686 <- Coverage_intergenic_SRR22672686 %>%
  rename(SRR22672686_Cov = coverage)
Coverage_intergenic_SRR22672687 <- Coverage_intergenic_SRR22672687 %>%
  rename(SRR22672687_Cov = coverage)

#Get average coverage into new column
AC_intergenic_SRR22672685 <- Coverage_intergenic_SRR22672685 %>%
  group_by(ids) %>%
  summarize(SRR22672685_AveCov = mean(SRR22672685_Cov)) %>%
  mutate(SRR22672685_AveCov = as.numeric(sprintf("%.7f", SRR22672685_AveCov))) %>%
  ungroup()

AC_intergenic_SRR22672686 <- Coverage_intergenic_SRR22672686 %>%
  group_by(ids) %>%
  summarize(SRR22672686_AveCov = mean(SRR22672686_Cov)) %>%
  mutate(SRR22672686_AveCov = as.numeric(sprintf("%.7f", SRR22672686_AveCov))) %>%
  ungroup()

AC_intergenic_SRR22672687 <- Coverage_intergenic_SRR22672687 %>%
  group_by(ids) %>%
  summarize(SRR22672687_AveCov = mean(SRR22672687_Cov)) %>%
  mutate(SRR22672687_AveCov = as.numeric(sprintf("%.7f", SRR22672687_AveCov))) %>%
  ungroup()

#Get number of zero into new column
nZero_intergenic_SRR22672685 <- Coverage_intergenic_SRR22672685 %>%
  group_by(ids) %>%
  mutate(SRR22672685_nZero = sum(SRR22672685_Cov == 0)) %>%
  ungroup() %>%
  dplyr::select(ids, SRR22672685_nZero)%>%
  unique()

nZero_intergenic_SRR22672686 <- Coverage_intergenic_SRR22672686 %>%
  group_by(ids) %>%
  mutate(SRR22672686_nZero = sum(SRR22672686_Cov == 0)) %>%
  ungroup() %>%
  dplyr::select(ids, SRR22672686_nZero)%>%
  unique()

nZero_intergenic_SRR22672687 <- Coverage_intergenic_SRR22672687 %>%
  group_by(ids) %>%
  mutate(SRR22672687_nZero = sum(SRR22672687_Cov == 0)) %>%
  ungroup() %>%
  dplyr::select(ids, SRR22672687_nZero) %>%
  unique()

###Intron1
Coverage_Intron1_SRR22672685 <- Intron1_coverage_SRR22672685 %>%
  left_join(intron.closest, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_Intron1_SRR22672686 <- Intron1_coverage_SRR22672686 %>%
  left_join(intron.closest, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_Intron1_SRR22672687 <- Intron1_coverage_SRR22672687 %>%
  left_join(intron.closest, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

#Get average coverage into new column
AC_Intron1_SRR22672685 <- Coverage_Intron1_SRR22672685 %>%
  group_by(ids) %>%
  summarize(SRR22672685_AveCov = mean(coverage)) %>%
  mutate(SRR22672685_AveCov = as.numeric(sprintf("%.7f", SRR22672685_AveCov))) %>%
  ungroup()

AC_Intron1_SRR22672686 <- Coverage_Intron1_SRR22672686 %>%
  group_by(ids) %>%
  summarize(SRR22672686_AveCov = mean(coverage)) %>%
  mutate(SRR22672686_AveCov = as.numeric(sprintf("%.7f", SRR22672686_AveCov))) %>%
  ungroup()

AC_Intron1_SRR22672687 <- Coverage_Intron1_SRR22672687 %>%
  group_by(ids) %>%
  summarize(SRR22672687_AveCov = mean(coverage)) %>%
  mutate(SRR22672687_AveCov = as.numeric(sprintf("%.7f", SRR22672687_AveCov))) %>%
  ungroup()

###Intron2
Coverage_Intron2_SRR22672685 <- Intron2_coverage_SRR22672685 %>%
  left_join(intron.2nd.closest.info.bed, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_Intron2_SRR22672686 <- Intron2_coverage_SRR22672686 %>%
  left_join(intron.2nd.closest.info.bed, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_Intron2_SRR22672687 <- Intron2_coverage_SRR22672687 %>%
  left_join(intron.2nd.closest.info.bed, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

#Get average coverage into new column
AC_Intron2_SRR22672685 <- Coverage_Intron2_SRR22672685 %>%
  group_by(ids) %>%
  summarize(SRR22672685_AveCov = mean(coverage)) %>%
  mutate(SRR22672685_AveCov = as.numeric(sprintf("%.7f", SRR22672685_AveCov))) %>%
  ungroup()

AC_Intron2_SRR22672686 <- Coverage_Intron2_SRR22672686 %>%
  group_by(ids) %>%
  summarize(SRR22672686_AveCov = mean(coverage)) %>%
  mutate(SRR22672686_AveCov = as.numeric(sprintf("%.7f", SRR22672686_AveCov))) %>%
  ungroup()

AC_Intron2_SRR22672687 <- Coverage_Intron2_SRR22672687 %>%
  group_by(ids) %>%
  summarize(SRR22672687_AveCov = mean(coverage)) %>%
  mutate(SRR22672687_AveCov = as.numeric(sprintf("%.7f", SRR22672687_AveCov))) %>%
  ungroup()
```
#Now bind 3 samples intergenic coverage, intergenic number of zero, intron1 coverage, intron2 coverage together
```{r}
#Average Coverage
AC.intergenic <- AC_intergenic_SRR22672685 %>%
  left_join(AC_intergenic_SRR22672686, by = "ids") %>%
  left_join(AC_intergenic_SRR22672687, by = "ids")

AC.intron.closest <- AC_Intron1_SRR22672685 %>%
  left_join(AC_Intron1_SRR22672686, by = "ids") %>%
  left_join(AC_Intron1_SRR22672687, by = "ids")

AC.intron.2nd.closest <- AC_Intron2_SRR22672685 %>%
  left_join(AC_Intron2_SRR22672686, by = "ids") %>%
  left_join(AC_Intron2_SRR22672687, by = "ids")

#Number of zero coverage base pair in intergenic region
nZero.intergenic <- nZero_intergenic_SRR22672685 %>%
  left_join(nZero_intergenic_SRR22672686, by = "ids") %>%
  left_join(nZero_intergenic_SRR22672687, by = "ids")
```
# gethering Average Coverage data for t-test
```{r}
AC.final <- do.call("rbind", list(AC.intergenic,
                                  AC.intron.closest,
                                  AC.intron.2nd.closest))
```
## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(tRNA.up.intergenic, intron.closest.for.stats.up, by = "gene.id")
intron.closest.up.data <- data_frame(chr = x1$chr.y,
                                     start = x1$start.y,
                                     end = x1$end.y,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.y,
                                     id = x1$ids.x,
                                     type = x1$type.y,
                                     length = x1$length.y,
                                     sameStrand = x1$sameStrand.y,
                                     tRNAFirst = x1$tRNAFirst.y,
                                     tRNA.upstream = x1$tRNA.upstream.y)

x1 <- merge(tRNA.down.intergenic, intron.closest.for.stats.down, by = "gene.id")
intron.closest.down.data <- data_frame(chr = x1$chr.y,
                                       start = x1$start.y,
                                       end = x1$end.y,
                                       ids = x1$ids.y,
                                       gene.id = x1$gene.id,
                                       strand = x1$gene.strand.y,
                                       id = x1$ids.x,
                                       type = x1$type.y,
                                       length = x1$length.y,
                                       sameStrand = x1$sameStrand.y,
                                       tRNAFirst = x1$tRNAFirst.y,
                                       tRNA.upstream = x1$tRNA.upstream.y)

x1 <- merge(tRNA.up.intergenic, intron.2nd_closest.for.stats.up, by = "gene.id")
intron.2nd.closest.up.data <- data_frame(chr = x1$chr.y,
                                         start = x1$start.y,
                                         end = x1$end.y,
                                         ids = x1$ids.y,
                                         gene.id = x1$gene.id,
                                         strand = x1$gene.strand.y,
                                         id = x1$ids.x,
                                         type = x1$type.y,
                                         length = x1$length.y,
                                         sameStrand = x1$sameStrand.y,
                                         tRNAFirst = x1$tRNAFirst.y,
                                         tRNA.upstream = x1$tRNA.upstream.y)

x1 <- merge(tRNA.down.intergenic, intron.2nd_closest.for.stats.down, by = "gene.id")
intron.2nd.closest.down.data <- data_frame(chr = x1$chr.y,
                                           start = x1$start.y,
                                           end = x1$end.y,
                                           ids = x1$ids.y,
                                           gene.id = x1$gene.id,
                                           strand = x1$gene.strand.y,
                                           id = x1$ids.x,
                                           type = x1$type.y,
                                           length = x1$length.y,
                                           sameStrand = x1$sameStrand.y,
                                           tRNAFirst = x1$tRNAFirst.y,
                                           tRNA.upstream = x1$tRNA.upstream.y)

# form porper intergenic data
intergenic.data <- intergenic.info %>%
  dplyr::select(chr, start, end, ids, gene.id, strand, type, length, sameStrand, tRNAFirst, tRNA.upstream) %>%
  add_column(id = id, .after = "strand")

# put everything togeher
final.stats.parid <- do.call("rbind", list(intron.closest.up.data,
                                           intron.closest.down.data,
                                           intron.2nd.closest.up.data,
                                           intron.2nd.closest.down.data,
                                           intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
final.stats.test <- final.stats.parid %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length)

aveCoverage.all <- AC.final %>%
  left_join(final.stats.test, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final <- aveCoverage.all %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_tibble() %>% 
  arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene <- aveCoverage.final %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 2 elements with different comparison and do the t.test
tTestResults.final <- tRnaToGene$ids %>% 
  # extract(1) %>%
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene, ids ==x)$id
    cov <- filter(aveCoverage.final, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )
    
    # Compare the introns
    if (all(c("intron_2nd_closest_to_intergenic", "intron_closest_to_intergenic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_closest_to_intergenic"]+1),
                      log(cov[,"intron_2nd_closest_to_intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intron_2nd_closest_to_intergenicVsintron_closest_to_intergenic",
                     df = tTest$parameter, # degree of freedom
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    
    # Compare the intergenic regions
    if (all(c("intergenic", "intron_closest_to_intergenic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_closest_to_intergenic"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intergenicVsintron_closest_to_intergenic",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## t.test output
```{r two way filtering}
# for FDR
 intergeic.sign.final <- tTestResults.final$intergenicVsintron_closest_to_intergenic %>% 
    filter(FDR < 0.05, V < 0) 
intron.not.sign.final <- tTestResults.final$intron_2nd_closest_to_intergenicVsintron_closest_to_intergenic %>% 
  filter((FDR < 0.05 & V > 0) | FDR >=0.05)
final.sign <- intersect(intron.not.sign.final$id,intergeic.sign.final$id)
#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
#intron.not.sign.final <- tTestResults.final$Intron2VsIntron1 %>% 
 # filter((adjP < 0.05 & V > 0) | adjP >=0.05) 
#final.sign.adjP <- intersect(intron.not.sign.final$id,intergeic.sign.final$id) 
```
## assess continuous coverage for candidates that pass the t.test
```{r}
coverage.list.final <- nZero.intergenic %>%
  merge(final.stats.parid, by = "ids") %>% 
 filter(id %in% final.sign) %>%
  mutate(continu.cov = rowSums(dplyr::select(., contains("nZero"))) == 0)

# make all coverage data addable for each sample and assess the continious Cov for combined coverage
keptIntergenic <- coverage.list.final$ids
coverage.samples.final <- Coverage_intergenic_SRR22672685 %>%
  left_join(Coverage_intergenic_SRR22672686, by = "position") %>%
  left_join(Coverage_intergenic_SRR22672687, by = "position") %>%  
  dplyr::select(ids, position, SRR22672685_Cov, SRR22672686_Cov, SRR22672687_Cov) %>%
  filter(ids %in% keptIntergenic)

combined.nZero <- coverage.samples.final %>%
  group_by(ids) %>%
  summarize(Combined.nZero = sum(SRR22672685_Cov == 0 & SRR22672686_Cov == 0 & SRR22672687_Cov == 0))


continuous.coverage.final <- left_join(coverage.list.final,combined.nZero, by = "ids") %>%
  mutate(Combined.nZero = Combined.nZero == 0) %>%
  setnames("Combined.nZero", "combined.continu.cov")
```
# export results
```{r}
##output the file
write.table(continuous.coverage.final,
            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Result/Barley827_Result_two_intron.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
```
#The underneath codes are modified by Fei Zheng. The codes use same functions from above to do t-test for candidates with one or no intron
####Candidates with one intron: by using intron 1 compare with intergenic region. Then, I will use the flanking region outside of tRNA with same length as intergenic region as intron2 to do two time t-test. In the end I will use the overlaping candidates as the final candidates pass t-test.
```{r}
# Use intron.1 do a single time t-test with intron.1 vs intergenic region
# get correct intron information for candidates with one intron
One.intron.info <- intron.info %>% 
  filter(gene.id %in% tgene.expressed.with2exon$gene.id)
# coordinates for the intron of candidates with one intron
intron.one <- data_frame(chr = One.intron.info$chr,
                                          start = One.intron.info$intron.start,
                                          end = One.intron.info$intron.end,
                                          strand = One.intron.info$gene.strand,
                                          ids = One.intron.info$intron.id,
                                          gene.id = One.intron.info$gene.id,
                                          type = rep("intron_for_one_intron", nrow(One.intron.info)),
                                          gene.strand = One.intron.info$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(One.intron.info)),
                                          tRNAFirst = rep("NA", nrow(One.intron.info)),
                                          tRNA.upstream = rep("NA", nrow(One.intron.info)))%>%
  group_by(gene.id) %>%
  slice_min(start, n = 1) %>% ungroup() %>%
  arrange(gene.id) %>% 
  unique()

# put together for calculate average coverage (AC): intron one, intergenic
One.intron.stats.info <- do.call("rbind", list(intron.one,
                                          intergenic.info)) %>%
  arrange(gene.id)
```
## use ``Cal_Coverage()`` to look through ``bam`` files for coverage of intron one
```{r, coverage of intron one}
# form a proper dataframe for all intron closest AC
AC.intron.one <- AC.intron.closest %>%
  filter(ids %in% intron.one$ids )

# gethering Average Coverage data for t-test
AC.intergenic.intron.one <- do.call("rbind", list(AC.intergenic,
                                  AC.intron.one))
```
## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(intergenic.info, intron.one, by = "gene.id")
intron.one.data <- data_frame(chr = x1$chr.y,
                                     start = x1$start.y,
                                     end = x1$end.y,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.y,
                                     id = x1$ids.x,
                                     type = x1$type.y,
                                     length = x1$length.y,
                                     sameStrand = x1$sameStrand.y,
                                     tRNAFirst = x1$tRNAFirst.y,
                                     tRNA.upstream = x1$tRNA.upstream.y) %>%
  mutate(id = sub(".*intergenic_", "",id))

# put everything togeher
One.intron.stats.parid <- do.call("rbind", list(intron.one.data,
                                           intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
One.intron.stats.test <- One.intron.stats.parid %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length)

aveCoverage.One.intron <- AC.intergenic.intron.one %>%
  left_join(One.intron.stats.test, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final.one.intron <- aveCoverage.One.intron %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_tibble() %>%
  arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene.one.intron <- aveCoverage.final.one.intron %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 1 elements with comparison of intron one to intergenic and do the t.test
tTestResults.final.for.one.intron <- tRnaToGene.one.intron$ids %>% 
  # extract(1) %>%
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene.one.intron, ids ==x)$id
    cov <- filter(aveCoverage.final.one.intron, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )

    # Compare the intergenic regions
    if (all(c("intergenic", "intron_for_one_intron") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_for_one_intron"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intergenicVsintron_for_one_intron",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## one step t.test output
```{r two way filtering}
# for FDR
intergeic.sign.final.one.intron <- tTestResults.final.for.one.intron$intergenicVsintron_for_one_intron %>% 
  filter(FDR < 0.05, V < 0) 
final.sign.with.one.intron <- intergeic.sign.final.one.intron$id
#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
```
######Using flanking region mimic intron 2 to do t-test for candidates with only one intron
######I can merge these two statistic into one down here, however, the published paper from Pastor Fabrus mentioned he did one way t-test with intergenic and intron. Therefore, I seperate the t-test into two part: up: one way t-test with intergenic and intron; down: mimic intron 2.
```{r}
# Get the flanking region from tRNA side which has same length as intergenic region and use it as intron.mimic.
One.intron.with.tRNA.info <- left_join(One.intron.info, tRNA.CDS.expressed.combo, by = 'gene.id') %>%
  dplyr::select(chr.x, tRNA.start, tRNA.end, tRNA.strand, id, gene.id, gene.strand.x, interval.length, gene.start, gene.end, tRNAFirst, tRNA.upstream) %>%
  set_colnames(c("chr.x", "tRNA.start", "tRNA.end", "tRNA.strand", "ids", "gene.id", "gene.strand.x", "interval.length", "gene.start", "gene.end", "tRNAFirst", "tRNA.upstream"))

# seperate tRNA first and gene first: If tRNA first, flanking region is before tRNA, end of intron mimic is 1 bp before start of tRNA. If gene first, flanking region is after tRNA, start of intron mimic is 1bp after end of tRNA.
tRNA.up.one.intron <- filter(One.intron.with.tRNA.info, 
                             tRNAFirst == TRUE)

tRNA.down.one.intron <- filter(One.intron.with.tRNA.info, 
                               tRNAFirst == FALSE)

#use same length of flancking region from tRNA side to mimic intron 1
One.intron.mimic.intron.up <- tRNA.up.one.intron %>% dplyr::select(chr.x, tRNA.start, tRNA.end, gene.id, gene.strand.x, interval.length, gene.start, gene.end) %>%
  mutate(tRNA.start = tRNA.start-1 ) #this is the end of mimic intron:one position before tRNA start
One.intron.mimic.intron.start <- c(tRNA.up.one.intron$tRNA.start-tRNA.up.one.intron$interval.length) #mimic intron start
One.intron.mimic.intron.ids <- c(".one.intron.mimic") #mimic intron id
One.intron.mimic.intron.up$One.intron.mimic.intron.start <- One.intron.mimic.intron.start 
One.intron.mimic.intron.up$One.intron.mimic.intron.ids <- One.intron.mimic.intron.ids 
One.intron.mimic.intron.up <- One.intron.mimic.intron.up %>% dplyr::select(chr.x, One.intron.mimic.intron.start, tRNA.start, gene.strand.x, One.intron.mimic.intron.ids, gene.id, interval.length) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "strand", "ids", "gene.id", "length"))  %>%
  mutate(ids=paste0(One.intron.mimic.intron.up$gene.id,ids))

#range for intron mimic up
One.intron.mimic.for.stats.up <- data_frame(chr = One.intron.mimic.intron.up$chr,
                                          start = One.intron.mimic.intron.up$intron.start,
                                          end = One.intron.mimic.intron.up$intron.end,
                                          strand = One.intron.mimic.intron.up$strand,
                                          ids = One.intron.mimic.intron.up$ids,
                                          gene.id = One.intron.mimic.intron.up$gene.id,
                                          type = rep("One_intron_mimic", nrow(One.intron.mimic.intron.up)),
                                          gene.strand = One.intron.mimic.intron.up$strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(One.intron.mimic.intron.up)),
                                          tRNAFirst = rep("NA", nrow(One.intron.mimic.intron.up)),
                                          tRNA.upstream = rep("NA", nrow(One.intron.mimic.intron.up)))


One.intron.mimic.intron.down <- tRNA.down.one.intron %>% dplyr::select(chr.x, tRNA.start, tRNA.end, gene.id, gene.strand.x, interval.length, gene.start, gene.end) %>%
  mutate(tRNA.end = tRNA.end+1 ) #this is the start of mimic intron when tRNA first=false: one position after tRNA end
One.intron.down.mimic.intron.end <- c(tRNA.down.one.intron$tRNA.end+tRNA.down.one.intron$interval.length) #mimic intron end
One.intron.down.mimic.intron.ids <- c(".one.intron.mimic") #mimic intron id
One.intron.mimic.intron.down$One.intron.down.mimic.intron.end <- One.intron.down.mimic.intron.end 
One.intron.mimic.intron.down$One.intron.down.mimic.intron.ids <- One.intron.down.mimic.intron.ids 
One.intron.mimic.intron.down <- One.intron.mimic.intron.down %>% dplyr::select(chr.x, tRNA.end, One.intron.down.mimic.intron.end, gene.strand.x, One.intron.down.mimic.intron.ids, gene.id, interval.length) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "strand", "ids", "gene.id", "length"))  %>%
  mutate(ids=paste0(One.intron.mimic.intron.down$gene.id,ids))

#range for intron mimic down
One.intron.mimic.for.stats.down <- data_frame(chr = One.intron.mimic.intron.down$chr,
                                          start = One.intron.mimic.intron.down$intron.start,
                                          end = One.intron.mimic.intron.down$intron.end,
                                          strand = One.intron.mimic.intron.down$strand,
                                          ids = One.intron.mimic.intron.down$ids,
                                          gene.id = One.intron.mimic.intron.down$gene.id,
                                          type = rep("One_intron_mimic", nrow(One.intron.mimic.intron.down)),
                                          gene.strand = One.intron.mimic.intron.down$strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(One.intron.mimic.intron.down)),
                                          tRNAFirst = rep("NA", nrow(One.intron.mimic.intron.down)),
                                          tRNA.upstream = rep("NA", nrow(One.intron.mimic.intron.down)))

#bind up and down to get intron mimic
One.intron.mimic <-   do.call("rbind", list(One.intron.mimic.for.stats.up,
                                            One.intron.mimic.for.stats.down)) %>%
  arrange(gene.id) %>% 
  unique() %>% group_by(gene.id) %>% slice_min(n = 1, length)%>%
    ungroup() #"group_by(gene.id) %>% slice_min(n = 1, length)%>% ungroup()" this part is because for same gene id, we can get more than one tRNA combinations. I select the most closest tRNA in the gene.tRNA combination for each gene.
```
#build bed file for One.intron mimic 
```{r}
# One.intron mimic
One.intron.mimic.info.bed <- One.intron.mimic %>%
   dplyr::select(chr, start, end, ids) %>%
    dplyr::mutate(start = start - 1)
 #output the file
 write.table(One.intron.mimic.info.bed,
             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/One_intron_mimic.bed",
             quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
```
## Count reads for intergenic, intron 1 and 2 bed file from your RNA seq bam files 
for i in {22672685..22672687}; do
  samtools depth -@ 30 -b One_intron_mimic.bed -a "SRR${i}_.sorted.bam" > "Cov_SRR${i}_One_intron_mimic.txt"
done

##load depth count from SAMtools 
```{r}
One_intron_mimic_coverage_SRR22672685 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672685_One_intron_mimic.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
One_intron_mimic_coverage_SRR22672686 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672686_One_intron_mimic.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
One_intron_mimic_coverage_SRR22672687 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672687_One_intron_mimic.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
```
## use summaruze mean for coverage of intron mimic
```{r, coverage of intron mimic}
###Intron1
Coverage_One_intron_mimic_SRR22672685 <- One_intron_mimic_coverage_SRR22672685 %>%
  left_join(One.intron.mimic, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_One_intron_mimic_SRR22672686 <- One_intron_mimic_coverage_SRR22672686 %>%
  left_join(One.intron.mimic, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_One_intron_mimic_SRR22672687 <- One_intron_mimic_coverage_SRR22672687 %>%
  left_join(One.intron.mimic, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

#Get average coverage into new column
AC_One_intron_mimic_SRR22672685 <- Coverage_One_intron_mimic_SRR22672685 %>%
  group_by(ids) %>%
  summarize(SRR22672685_AveCov = mean(coverage)) %>%
  mutate(SRR22672685_AveCov = as.numeric(sprintf("%.7f", SRR22672685_AveCov))) %>%
  ungroup()

AC_One_intron_mimic_SRR22672686 <- Coverage_One_intron_mimic_SRR22672686 %>%
  group_by(ids) %>%
  summarize(SRR22672686_AveCov = mean(coverage)) %>%
  mutate(SRR22672686_AveCov = as.numeric(sprintf("%.7f", SRR22672686_AveCov))) %>%
  ungroup()

AC_One_intron_mimic_SRR22672687 <- Coverage_One_intron_mimic_SRR22672687 %>%
  group_by(ids) %>%
  summarize(SRR22672687_AveCov = mean(coverage)) %>%
  mutate(SRR22672687_AveCov = as.numeric(sprintf("%.7f", SRR22672687_AveCov))) %>%
  ungroup()
```

```{r}
AC_One_intron_mimic <- AC_One_intron_mimic_SRR22672685 %>%
  left_join(AC_One_intron_mimic_SRR22672686, by = "ids") %>%
  left_join(AC_One_intron_mimic_SRR22672687, by = "ids")
#I want to filter the AC.intergenic to leave gene with only one intron


AC.intergenic_one_intron <- AC.intergenic %>% left_join(intergenic.info, by = "ids") %>% filter(gene.id %in% One.intron.mimic$gene.id) %>% dplyr::select(ids, SRR22672685_AveCov,SRR22672686_AveCov,SRR22672687_AveCov)


# gethering Average Coverage data for t-test
AC.final.one.intron.with.mimic<- do.call("rbind", list(AC.intergenic_one_intron,
                                  AC.intron.one,
                                  AC_One_intron_mimic))
```
## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(tRNA.up.one.intron, One.intron.mimic.for.stats.up, by = "gene.id")
intron.One.mimic.up.data <- data_frame(chr = x1$chr,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.x,
                                     id = x1$ids.x,
                                     type = x1$type,
                                     length = x1$length,
                                     sameStrand = x1$sameStrand,
                                     tRNAFirst = x1$tRNAFirst.x,
                                     tRNA.upstream = x1$tRNA.upstream.x)

x1 <- merge(tRNA.down.one.intron, One.intron.mimic.for.stats.down, by = "gene.id")
intron.One.mimic.down.data <- data_frame(chr = x1$chr,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.x,
                                     id = x1$ids.x,
                                     type = x1$type,
                                     length = x1$length,
                                     sameStrand = x1$sameStrand,
                                     tRNAFirst = x1$tRNAFirst.x,
                                     tRNA.upstream = x1$tRNA.upstream.x)

# put everything togeher
final.stats.parid.One.intron.mimic <- do.call("rbind", list(intron.one.data,
                                           intron.One.mimic.up.data,
                                           intron.One.mimic.down.data,
                                           intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
final.stats.test.intron.one.mimic <- final.stats.parid.One.intron.mimic %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length)

aveCoverage.all.one.intron.mimic <- AC.final.one.intron.with.mimic %>%
  left_join(final.stats.test.intron.one.mimic, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final.one.intron.mimic <- aveCoverage.all.one.intron.mimic %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_data_frame() %>%group_by(ids) %>% slice_min(n = 1, start)%>%
    ungroup()%>% arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene.one.intron.mimic <- aveCoverage.final.one.intron.mimic %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 2 elements with different comparison and do the t.test
tTestResults.final.for.one.intron.mimic <- tRnaToGene.one.intron.mimic$ids %>% 
  # extract(1) %>%
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene.one.intron.mimic, ids ==x)$id
    cov <- filter(aveCoverage.final.one.intron.mimic, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )
    
    # Compare the introns
    if (all(c("intron_for_one_intron", "One_intron_mimic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_for_one_intron"]+1),
                      log(cov[,"One_intron_mimic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "One_intron_mimicVsintron_for_one_intron",
                     df = tTest$parameter, # degree of freedom
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    
    # Compare the intergenic regions
    if (all(c("intergenic", "intron_for_one_intron") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_for_one_intron"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intergenicVsintron_for_one_intron",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## t.test output
```{r two way filtering}
# for FDR
intergeic.sign.final.intron.one.mimic <- tTestResults.final.for.one.intron.mimic$intergenicVsintron_for_one_intron %>% 
  filter(FDR < 0.05, V < 0) 
intron.not.sign.final.mimic <- tTestResults.final.for.one.intron.mimic$One_intron_mimicVsintron_for_one_intron %>% 
  filter((FDR < 0.05 & V > 0) | FDR >=0.05)
final.sign.with.mimic.intron <- intersect(intron.not.sign.final.mimic$id,intergeic.sign.final.intron.one.mimic$id)

#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
#intron.not.sign.final <- tTestResults.final$Intron2VsIntron1 %>% 
 # filter((adjP < 0.05 & V > 0) | adjP >=0.05) 
#final.sign.adjP <- intersect(intron.not.sign.final$id,intergeic.sign.final$id) 
```
###filter ids that overlapped with two methods
```{r}
final.sign.overlap <- intersect(final.sign.with.one.intron,final.sign.with.mimic.intron)
```
## assess continuous coverage for candidates that pass the t.test
```{r}
coverage.list.final.one.intron <- nZero.intergenic %>%
  merge(final.stats.parid, by = "ids") %>% 
 filter(id %in% final.sign.overlap) %>%
  mutate(continu.cov = rowSums(dplyr::select(., contains("nZero"))) == 0)

#only one gene with more than 5000 gaps, no need for next
```
# export results
```{r}
write.table(continuous.coverage.final.one.intron,
            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Arabidopsis/Result/Arabi286nano_Result_with_one_intron.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
```
######I want to do t-test for tRNA.gene.expression with no intron. I can use the flanking region outside of tRNA with same length as intergenic region to mimic intron
```{r}
# get tgene.expressed without intron
# get tgene.expressed with one exon, one exon means no intron 
tgene.expressed.no.intron <- left_join(tgene.only.one.exon,tRNA.CDS.combo,by = "gene.id") %>%
  dplyr::select(chr.x, gene.start, gene.end, gene.id, gene.strand.x) %>%
    set_colnames(c("gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand"))%>%
    arrange(gene.chr, gene.start)%>%
  unique()
#output the tRNA:mRNA expressed no intron, this file will be used to find the gene with two intron in next step when I try to do t-test with introns from nearby genes. 
write.table(tgene.expressed.no.intron,
            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Barley827_tRNA_gene_expressed_no_intron.txt",
            quote = FALSE, sep = "\t",
            row.names = FALSE, col.names = FALSE)
#get intron information (gene and tRNA combination, coordinate and strands) for candidates without intron
no.intron.info <- left_join(tgene.expressed.no.intron,tRNA.CDS.expressed.combo, by = "gene.id") %>%
  unique() %>%
  dplyr::select(chr,id, interval.length, tRNAFirst, tRNA.upstream, gene.id, gene.strand.x, tRNA.start, tRNA.end, tRNA.id, tRNA.strand, gene.start.x, gene.end.x) %>%
    set_colnames(c("chr", "id","length", "tRNAFirst", "tRNA.upstream", "gene.id", "gene.strand", "tRNA.start", "tRNA.end", "tRNA.id", "tRNA.strand", "gene.start", "gene.end")) 
sameStrand = no.intron.info$tRNA.strand == no.intron.info$gene.strand
no.intron.info <-  cbind(no.intron.info,sameStrand)
```
#get intron mimic infor
```{r}
# get the region which has same length as intergenic region and use it as mimic introns 
# seperate tRNA first and gene first
tRNA.up.no.intron <- filter(no.intron.info, 
                             tRNAFirst == TRUE)

tRNA.down.no.intron <- filter(no.intron.info, 
                               tRNAFirst == FALSE)
###MIMIC INTRON 1
#For tRNA first (up), use same length from tRNA to mimic intron 1 
no.intron.mimic.intron1.up <- tRNA.up.no.intron %>% dplyr::select(chr, tRNA.start, tRNA.end, gene.id, gene.strand, length, gene.start, gene.end) %>%
  mutate(tRNA.start = tRNA.start-1 ) #this is the end of mimic intron 1 for tRNA up
no.intron.mimic.intron1.ids <- c("intron.1") # give mimic intron an id
no.intron.mimic.intron1.start <- c(no.intron.mimic.intron1.up$tRNA.start+1-no.intron.mimic.intron1.up$length) #this is the start of mimic intron1 for tRNA up
no.intron.mimic.intron1.up$no.intron.mimic.intron1.start <- no.intron.mimic.intron1.start 
no.intron.mimic.intron1.up$no.intron.mimic.intron1.ids <- paste(no.intron.mimic.intron1.up$gene.id, no.intron.mimic.intron1.ids, sep = ".") #combine gene id with intron id
no.intron.mimic.intron1.up <- no.intron.mimic.intron1.up %>% dplyr::select(chr, no.intron.mimic.intron1.start, tRNA.start, gene.strand, no.intron.mimic.intron1.ids, gene.id, length) %>%
  set_colnames(c("chr", "intron.start", "intron.end","gene.strand","ids", "gene.id", "length")) #put together as a dataframe

#For tRNA not first (down), use same length from tRNA to mimic intron 1
no.intron.mimic.intron1.down <- tRNA.down.no.intron %>% dplyr::select(chr, tRNA.start, tRNA.end, gene.id, gene.strand, length, gene.start, gene.end) %>%
  mutate(tRNA.end = tRNA.end+1 ) #this is the start of mimic intron 1 for tRNA down
no.intron.mimic.intron1.ids <- c("intron.1") # give mimic intron an id
no.intron.mimic.intron1.end <- c(no.intron.mimic.intron1.down$tRNA.end+no.intron.mimic.intron1.down$length) #this is the start of mimic intron1 for tRNA up
no.intron.mimic.intron1.down$no.intron.mimic.intron1.end <- no.intron.mimic.intron1.end
no.intron.mimic.intron1.down$no.intron.mimic.intron1.ids <- paste(no.intron.mimic.intron1.down$gene.id, no.intron.mimic.intron1.ids, sep = ".") #combine gene id with intron id
no.intron.mimic.intron1.down <- no.intron.mimic.intron1.down %>% dplyr::select(chr, tRNA.end, no.intron.mimic.intron1.end, gene.strand, no.intron.mimic.intron1.ids, gene.id, length) %>%
  set_colnames(c("chr", "intron.start", "intron.end","gene.strand","ids", "gene.id", "length"))  #put together as a dataframe

###MIMIC INTRON 2
#For tRNA first (up), use same length from gene to mimic intron 2
no.intron.mimic.intron2.up <- tRNA.up.no.intron %>% dplyr::select(chr, tRNA.start, tRNA.start, gene.id, gene.strand, length, gene.start, gene.end) %>%
  mutate(gene.start = gene.end+1 ) #this is the start of the mimic intron2 for tRNA up
no.intron.mimic.intron2.end <- c(no.intron.mimic.intron2.up$gene.end+no.intron.mimic.intron2.up$length) #this is the end of the mimic intron2 for tRNA up. I use gene.end but not gene.end +1 is because gene end +1 is the first bp of interval.
no.intron.mimic.intron2.ids <- c("intron.2")
no.intron.mimic.intron2.up$no.intron.mimic.intron2.end <- no.intron.mimic.intron2.end 
no.intron.mimic.intron2.up$no.intron.mimic.intron2.ids <- paste(no.intron.mimic.intron2.up$gene.id, no.intron.mimic.intron2.ids, sep = ".") 
no.intron.mimic.intron2.up <- no.intron.mimic.intron2.up %>% dplyr::select(chr, gene.start, no.intron.mimic.intron2.end, gene.strand, no.intron.mimic.intron2.ids, gene.id, length) %>%
  set_colnames(c("chr", "intron.start", "intron.end","gene.strand","ids", "gene.id", "length"))

#For tRNA not first (down), use same length from gene to mimic intron 2
no.intron.mimic.intron2.down <- tRNA.down.no.intron %>% dplyr::select(chr, tRNA.start, tRNA.start, gene.id, gene.strand, length, gene.start, gene.end) %>%
  mutate(gene.start = gene.start-1 ) #this is the end of mimic intron 2 for tRNA up
no.intron.mimic.intron2.ids <- c("intron.2")
no.intron.mimic.intron2.start <- c(tRNA.down.no.intron$gene.start-tRNA.down.no.intron$length) #this is the start of the mimic intron2 for tRNA up.
no.intron.mimic.intron2.down$no.intron.mimic.intron2.ids <- paste(no.intron.mimic.intron2.down$gene.id, no.intron.mimic.intron2.ids, sep = ".")
no.intron.mimic.intron2.down$no.intron.mimic.intron2.start <- no.intron.mimic.intron2.start
no.intron.mimic.intron2.down <- no.intron.mimic.intron2.down %>% dplyr::select(chr, no.intron.mimic.intron2.start,gene.start, gene.strand, no.intron.mimic.intron2.ids, gene.id, length) %>%
  set_colnames(c("chr", "intron.start", "intron.end","gene.strand","ids", "gene.id", "length"))

#make statistic dataframe for intron 1 up
intron1.mimic.for.stats.up <- data_frame(chr = no.intron.mimic.intron1.up$chr,
                                          start = no.intron.mimic.intron1.up$intron.start,
                                          end = no.intron.mimic.intron1.up$intron.end,
                                          strand = no.intron.mimic.intron1.up$gene.strand,
                                          ids = no.intron.mimic.intron1.up$ids,
                                          gene.id = no.intron.mimic.intron1.up$gene.id,
                                          type = rep("intron1_mimic", nrow(no.intron.mimic.intron1.up)),
                                          gene.strand = no.intron.mimic.intron1.up$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(no.intron.mimic.intron1.up)),
                                          tRNAFirst = rep("NA", nrow(no.intron.mimic.intron1.up)),
                                          tRNA.upstream = rep("NA", nrow(no.intron.mimic.intron1.up)))
#make statistic dataframe for intron 1 down
intron1.mimic.for.stats.down <- data_frame(chr = no.intron.mimic.intron1.down$chr,
                                          start = no.intron.mimic.intron1.down$intron.start,
                                          end = no.intron.mimic.intron1.down$intron.end,
                                          strand = no.intron.mimic.intron1.down$gene.strand,
                                          ids = no.intron.mimic.intron1.down$ids,
                                          gene.id = no.intron.mimic.intron1.down$gene.id,
                                          type = rep("intron1_mimic", nrow(no.intron.mimic.intron1.down)),
                                          gene.strand = no.intron.mimic.intron1.down$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(no.intron.mimic.intron1.down)),
                                          tRNAFirst = rep("NA", nrow(no.intron.mimic.intron1.down)),
                                          tRNA.upstream = rep("NA", nrow(no.intron.mimic.intron1.down)))

#make statistic dataframe for intron 2 up
intron2.mimic.for.stats.up <- data_frame(chr = no.intron.mimic.intron2.up$chr,
                                            start = no.intron.mimic.intron2.up$intron.start,
                                            end = no.intron.mimic.intron2.up$intron.end,
                                            strand = no.intron.mimic.intron2.up$gene.strand,
                                            ids = no.intron.mimic.intron2.up$ids,
                                            gene.id = no.intron.mimic.intron2.up$gene.id,
                                            type = rep("intron2_mimic", nrow(no.intron.mimic.intron2.up)),
                                            gene.strand = no.intron.mimic.intron2.up$gene.strand,
                                            length = end-start+1,
                                            sameStrand = rep("NA", nrow(no.intron.mimic.intron2.up)),
                                            tRNAFirst = rep("NA", nrow(no.intron.mimic.intron2.up)),
                                            tRNA.upstream = rep("NA", nrow(no.intron.mimic.intron2.up)))

#make statistic dataframe for intron 2 down
intron2.mimic.for.stats.down <- data_frame(chr = no.intron.mimic.intron2.down$chr,
                                            start = no.intron.mimic.intron2.down$intron.start,
                                            end = no.intron.mimic.intron2.down$intron.end,
                                            strand = no.intron.mimic.intron2.down$gene.strand,
                                            ids = no.intron.mimic.intron2.down$ids,
                                            gene.id = no.intron.mimic.intron2.down$gene.id,
                                            type = rep("intron2_mimic", nrow(no.intron.mimic.intron2.down)),
                                            gene.strand = no.intron.mimic.intron2.down$gene.strand,
                                            length = end-start+1,
                                            sameStrand = rep("NA", nrow(no.intron.mimic.intron2.down)),
                                            tRNAFirst = rep("NA", nrow(no.intron.mimic.intron2.down)),
                                            tRNA.upstream = rep("NA", nrow(no.intron.mimic.intron2.down)))

# combine info together for mimic intron1 and 2
no.intron.mimic.intron1 <- do.call("rbind", list(intron1.mimic.for.stats.up,
                                                 intron1.mimic.for.stats.down))%>%
  arrange(gene.id) %>% 
  unique() %>% group_by(gene.id) %>% slice_min(n = 1, length) %>%
    ungroup()

no.intron.mimic.intron2 <- do.call("rbind",list(intron2.mimic.for.stats.up,
                                                intron2.mimic.for.stats.down)) %>%
                                                 
  arrange(gene.id) %>% 
  unique() %>% group_by(gene.id) %>% slice_min(n = 1, length)%>%
    ungroup()
#as bedtools closest use tRNA to find nearby gene, then one gene can have several tRNA nearby, I choose the closest tRNA and gene combination as intergenic info 
intergenic.info.no.intron <- intergenic.info %>% group_by(gene.id) %>% slice_min(n = 1, length)%>%
    ungroup() %>%
  filter(gene.id %in% no.intron.info$gene.id )
# put everything together for calculate average coverage (AC)
final.stats.info.no.intron <- do.call("rbind", list(no.intron.mimic.intron1,
                                          no.intron.mimic.intron2,
                                          intergenic.info.no.intron)) %>%
  arrange(gene.id)
```
#build bed file for One.intron mimic 
```{r}
# intron mimic 1
no.intron.mimic.intron1.bed <- no.intron.mimic.intron1 %>%
   dplyr::select(chr, start, end, ids) %>%
    dplyr::mutate(start = start - 1)
 #output the file
 write.table(no.intron.mimic.intron1.bed,
             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/no_intron_mimic_intron1.bed",
             quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
# intron mimic 2
no.intron.mimic.intron2.bed <- no.intron.mimic.intron2 %>%
   dplyr::select(chr, start, end, ids) %>%
    dplyr::mutate(start = start - 1)
 #output the file
 write.table(no.intron.mimic.intron2.bed,
             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/no_intron_mimic_intron2.bed",
             quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
```
## Count reads for intergenic, intron 1 and 2 bed file from your RNA seq bam files 
for i in {22672685..22672687}; do
  samtools depth -@ 30 -b no_intron_mimic_intron1.bed -a "SRR${i}_.sorted.bam" > "Cov_SRR${i}_no_intron_mimic_intron1.txt"
  samtools depth -@ 30 -b no_intron_mimic_intron2.bed -a "SRR${i}_.sorted.bam" > "Cov_SRR${i}_no_intron_mimic_intron2.txt"
done

##load depth count from SAMtools 
```{r}
#mimic intron1 
no_intron_mimic_intron1_coverage_SRR22672685 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672685_no_intron_mimic_intron1.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
no_intron_mimic_intron1_coverage_SRR22672686 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672686_no_intron_mimic_intron1.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
no_intron_mimic_intron1_coverage_SRR22672687 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672687_no_intron_mimic_intron1.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
#mimic intron 2 
no_intron_mimic_intron2_coverage_SRR22672685 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672685_no_intron_mimic_intron2.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
no_intron_mimic_intron2_coverage_SRR22672686 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672686_no_intron_mimic_intron2.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
no_intron_mimic_intron2_coverage_SRR22672687 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672687_no_intron_mimic_intron2.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
```
## use summaruze mean for coverage of intron mimic
```{r, coverage of intron mimic}
###Intron1
Coverage_no_intron_mimic_intron1_SRR22672685 <- no_intron_mimic_intron1_coverage_SRR22672685 %>%
  left_join(no.intron.mimic.intron1, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_no_intron_mimic_intron1_SRR22672686 <- no_intron_mimic_intron1_coverage_SRR22672686 %>%
  left_join(no.intron.mimic.intron1, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_no_intron_mimic_intron1_SRR22672687 <- no_intron_mimic_intron1_coverage_SRR22672687 %>%
  left_join(no.intron.mimic.intron1, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

#Get average coverage into new column
AC_no_intron_mimic_intron1_SRR22672685 <- Coverage_no_intron_mimic_intron1_SRR22672685 %>%
  group_by(ids) %>%
  summarize(SRR22672685_AveCov = mean(coverage)) %>%
  mutate(SRR22672685_AveCov = as.numeric(sprintf("%.7f", SRR22672685_AveCov))) %>%
  ungroup()

AC_no_intron_mimic_intron1_SRR22672686 <- Coverage_no_intron_mimic_intron1_SRR22672686 %>%
  group_by(ids) %>%
  summarize(SRR22672686_AveCov = mean(coverage)) %>%
  mutate(SRR22672686_AveCov = as.numeric(sprintf("%.7f", SRR22672686_AveCov))) %>%
  ungroup()

AC_no_intron_mimic_intron1_SRR22672687 <- Coverage_no_intron_mimic_intron1_SRR22672687 %>%
  group_by(ids) %>%
  summarize(SRR22672687_AveCov = mean(coverage)) %>%
  mutate(SRR22672687_AveCov = as.numeric(sprintf("%.7f", SRR22672687_AveCov))) %>%
  ungroup()

###Intron2
Coverage_no_intron_mimic_intron2_SRR22672685 <- no_intron_mimic_intron2_coverage_SRR22672685 %>%
  left_join(no.intron.mimic.intron2, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_no_intron_mimic_intron2_SRR22672686 <- no_intron_mimic_intron2_coverage_SRR22672686 %>%
  left_join(no.intron.mimic.intron2, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_no_intron_mimic_intron2_SRR22672687 <- no_intron_mimic_intron2_coverage_SRR22672687 %>%
  left_join(no.intron.mimic.intron2, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

#Get average coverage into new column
AC_no_intron_mimic_intron2_SRR22672685 <- Coverage_no_intron_mimic_intron2_SRR22672685 %>%
  group_by(ids) %>%
  summarize(SRR22672685_AveCov = mean(coverage)) %>%
  mutate(SRR22672685_AveCov = as.numeric(sprintf("%.7f", SRR22672685_AveCov))) %>%
  ungroup()

AC_no_intron_mimic_intron2_SRR22672686 <- Coverage_no_intron_mimic_intron2_SRR22672686 %>%
  group_by(ids) %>%
  summarize(SRR22672686_AveCov = mean(coverage)) %>%
  mutate(SRR22672686_AveCov = as.numeric(sprintf("%.7f", SRR22672686_AveCov))) %>%
  ungroup()

AC_no_intron_mimic_intron2_SRR22672687 <- Coverage_no_intron_mimic_intron2_SRR22672687 %>%
  group_by(ids) %>%
  summarize(SRR22672687_AveCov = mean(coverage)) %>%
  mutate(SRR22672687_AveCov = as.numeric(sprintf("%.7f", SRR22672687_AveCov))) %>%
  ungroup()
```
###Make 3 samples into one dataframe
```{r}
#no_intron_mimic_intron1
AC_no_intron_mimic_intron1 <- AC_no_intron_mimic_intron1_SRR22672685 %>%
  left_join(AC_no_intron_mimic_intron1_SRR22672686, by = "ids") %>%
  left_join(AC_no_intron_mimic_intron1_SRR22672687, by = "ids")
#no_intron_mimic_intron2
AC_no_intron_mimic_intron2 <- AC_no_intron_mimic_intron2_SRR22672685 %>%
  left_join(AC_no_intron_mimic_intron2_SRR22672686, by = "ids") %>%
  left_join(AC_no_intron_mimic_intron2_SRR22672687, by = "ids")
#no_intron intergenic
AC_intergenic_no_intron <- AC.intergenic %>% left_join(intergenic.info, by = "ids") %>% filter(gene.id %in% no.intron.info$gene.id) %>% dplyr::select(ids, SRR22672685_AveCov,SRR22672686_AveCov,SRR22672687_AveCov)

```

```{r}
# gethering Average Coverage data for t-test
AC.mimic.final <- do.call("rbind", list(AC_intergenic_no_intron,
                                  AC_no_intron_mimic_intron1,
                                  AC_no_intron_mimic_intron2))
```
## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(tRNA.up.no.intron, intron1.mimic.for.stats.up, by = "gene.id")
intron1.mimic.up.data <- data_frame(chr = x1$chr.y,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.y,
                                     id = x1$id,
                                     type = x1$type,
                                     length = x1$length.y,
                                     sameStrand = x1$sameStrand.y,
                                     tRNAFirst = x1$tRNAFirst.y,
                                     tRNA.upstream = x1$tRNA.upstream.y)
#tRNA downstream data frame has two rows with same gene id, and two rows with same length, so I will add a colonm on tRNA.down.no.intron with ids.
tRNA.down.no.intron$ids <- c(intron1.mimic.for.stats.down$ids)
x1 <- merge(tRNA.down.no.intron, intron1.mimic.for.stats.down, by = "gene.id")
intron1.mimic.down.data <- data_frame(chr = x1$chr.y,
                                       start = x1$start,
                                       end = x1$end,
                                       ids = x1$ids.y,
                                       gene.id = x1$gene.id,
                                       strand = x1$gene.strand.y,
                                       id = x1$id,
                                       type = x1$type,
                                       length = x1$length.y,
                                       sameStrand = x1$sameStrand.y,
                                       tRNAFirst = x1$tRNAFirst.y,
                                       tRNA.upstream = x1$tRNA.upstream.y)

x1 <- merge(tRNA.up.no.intron, intron2.mimic.for.stats.up, by = "gene.id")
intron2.mimic.up.data <- data_frame(chr = x1$chr.y,
                                         start = x1$start,
                                         end = x1$end,
                                         ids = x1$ids,
                                         gene.id = x1$gene.id,
                                         strand = x1$gene.strand.y,
                                         id = x1$id,
                                         type = x1$type,
                                         length = x1$length.y,
                                         sameStrand = x1$sameStrand.y,
                                         tRNAFirst = x1$tRNAFirst.y,
                                         tRNA.upstream = x1$tRNA.upstream.y)

tRNA.down.no.intron$ids <- c(intron2.mimic.for.stats.down$ids)
x1 <- merge(tRNA.down.no.intron, intron2.mimic.for.stats.down, by = "gene.id")
intron2.mimic.down.data <- data_frame(chr = x1$chr.y,
                                           start = x1$start,
                                           end = x1$end,
                                           ids = x1$ids.y,
                                           gene.id = x1$gene.id,
                                           strand = x1$gene.strand.y,
                                           id = x1$id,
                                           type = x1$type,
                                           length = x1$length.y,
                                           sameStrand = x1$sameStrand.y,
                                           tRNAFirst = x1$tRNAFirst.y,
                                           tRNA.upstream = x1$tRNA.upstream.y)

# form porper intergenic data
intergenic.data <- intergenic.info %>%
  dplyr::select(chr, start, end, ids, gene.id, strand, type, length, sameStrand, tRNAFirst, tRNA.upstream) %>%
  add_column(id = id, .after = "strand")

# put everything togeher
final.stats.parid.no.intron <- do.call("rbind", list(intron1.mimic.up.data,
                                                     intron1.mimic.down.data,
                                                     intron2.mimic.up.data,
                                                     intron2.mimic.down.data,
                                                     intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
final.stats.test.no.intron <- final.stats.parid.no.intron %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length) %>% group_by(ids) %>% slice_min(n = 1, length)%>%
    ungroup()

aveCoverage.all.no.intron <- AC.mimic.final %>%
  left_join(final.stats.test.no.intron, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final.no.intron <- aveCoverage.all.no.intron %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_data_frame() %>%  arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene.no.intron <- aveCoverage.final.no.intron %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 2 elements with different comparison and do the t.test
tTestResults.final.no.intron <- tRnaToGene.no.intron$ids %>% 
  # extract(1) %>% #extract 1 candidate and have a look
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene.no.intron, ids ==x)$id
    cov <- filter(aveCoverage.final.no.intron, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )
    
    # Compare the introns
    if (all(c("intron1_mimic", "intron2_mimic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron2_mimic"]+1),
                      log(cov[,"intron1_mimic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intron1_mimicVsintron2_mimic",
                     df = tTest$parameter, # degree of freedom
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    
    # Compare the intergenic regions
    if (all(c("intergenic", "intron1_mimic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron1_mimic"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intergenicVsintron1_mimic",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## t.test output
```{r two way filtering}
# for FDR
intergeic.sign.final.no.intron <- tTestResults.final.no.intron$intergenicVsintron1_mimic %>% 
  filter(FDR < 0.05, V < 0) 
intron.not.sign.final.no.intron <- tTestResults.final.no.intron$intron1_mimicVsintron2_mimic %>% 
  filter((FDR < 0.05 & V > 0) | FDR >=0.05)
final.sign.no.intron <- intersect(intron.not.sign.final.no.intron$id,intergeic.sign.final.no.intron$id)
#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
#intron.not.sign.final <- tTestResults.final$Intron2VsIntron1 %>% 
 # filter((adjP < 0.05 & V > 0) | adjP >=0.05) 
#final.sign.adjP <- intersect(intron.not.sign.final$id,intergeic.sign.final$id) 
```
###Now I will do t-test with another method: using introns from nearby gene which has two or more introns to mimic intron one and two 
## As we know introns are the only sure regions that do not have reads, so that is a better negative control of background reads and pre-mRNA reads. I will use the introns of nearby gene as control 
```{r}
####################################################################################################
# To get nearby gene, I need to get gene without intron and use samtool closed to get nearby gene information
#get gene information with 2 and more intron
gene.id.with.two.intron <- exon.info %>%
  filter(exon_UTR_id== "exon3")
gene.with.two.intron.info <- merge(gene.id.with.two.intron, CDS.start.end.for.gene, by = "gene.id") %>%
  dplyr::select(gene.chr, gene.start, gene.end, gene.id, gene.strand.y, gene.biotype) %>%
    arrange(gene.chr, gene.start) 
write.table(gene.with.two.intron.info,
            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Barley827_Nearby_gene_with_two_intron.txt",
            quote = FALSE, sep = "\t",
            row.names = FALSE, col.names = FALSE)
```
### Use tRNA_gene_expressed_no_intron.txt and Nearby_gene_with_two_intron.txt to find introns' position, and mimic two introns to the gene without inton. Don't foget Notepad ++ transfer EOI

do this on HPC with bedtool closest ignor overlaping setting

module load BEDTools
bedtools closest -io -a Barley827_tRNA_gene_expressed_no_intron.txt -b Barley827_Nearby_gene_with_two_intron.txt -g Hvgenome.txt -D ref > Barley827_closest_gene_gene.bed

```{r}
#combine gene information without intron to nearby gene information with two introns.
closest_gene.no.intron_gene <- read.delim("C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/Barley827_closest_gene_gene.bed", header=FALSE) %>% 
  unique() %>%
  set_colnames(c("chr", "no.intron.start", "no.intron.end", "no.intron.id", "no.intron.strand",
                 "nearby.gene.chr", "nearby.gene.start", "nearby.gene.end", "gene.id", "nearby.gene.strand","nearby.gene.biotype", "nearby.distance")) 

UTR_exon.all.gene.set1 <- exon.info %>% 
  dplyr::select(chr,start,end,exon_UTR_id,gene.id,gene.strand) %>%
  set_colnames(c("chr","start.set1","end.set1",
                 "exon_UTR_id.set1","gene.id.set1","gene.strand.set1"))

UTR_exon.all.gene.set2 <- exon.info[-1,] %>% 
  dplyr::select(start,end,exon_UTR_id,gene.id, gene.strand) %>%
  set_colnames(c("start.set2","end.set2",
                 "exon_UTR_id.set2","gene.id.set2","gene.strand.set2")) %>%
  rbind(c(0,0,NA,NA))

intron.info.all.gene <- cbind(UTR_exon.all.gene.set1, UTR_exon.all.gene.set2) %>% 
  filter(gene.id.set1 == gene.id.set2 & end.set1 < start.set2) %>%
  dplyr::select(chr, end.set1, start.set2, `exon_UTR_id.set1`, gene.id.set1, gene.strand.set1) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "intron.id","gene.id", "gene.strand")) %>%
  arrange(chr, intron.start) %>%
  mutate(intron.start = intron.start+1,
         intron.end = intron.end-1,
         intron.id = paste0(gene.id, '.intron'))

intron.num.all.gene <- sapply(as.character(unique(intron.info.all.gene$gene.id)), function(g){
  rowNb <- which(g == intron.info.all.gene$gene.id)
  strand <- intron.info.all.gene$gene.strand[rowNb]
  start <- intron.info.all.gene$intron.start[rowNb]
  order(ifelse(strand =="+", start, -start))
})  %>%  unlist()

intron.info.all.gene %>%
  group_by(gene.id) %>%
  mutate(paste0(intron.id=row_number(),intron.id))

intron.info.all.gene %<>% mutate(intron.id = paste0(intron.id,".", intron.num.all.gene)) 
#=========================================================================#
#allocate introns information to gene without intron from nearby gene
intron.info.no.intron.with.nearby <- left_join(closest_gene.no.intron_gene, intron.info.all.gene, by = "gene.id" ) %>%
  dplyr::select(chr.x, intron.start, intron.end, intron.id, no.intron.id, gene.strand ) %>%
  group_by(intron.id) %>% slice_min(n = 1, intron.start)%>%ungroup() %>% 
  unique()
```

```{r}
# corrdinates for closest intron to intergenic for tRNA.up.intergeic 
list.gene.id.nearby <- unique(no.intron.info$gene.id)
res <- sapply(list.gene.id.nearby,function(g){
  rowNb <- which(intron.info.no.intron.with.nearby$no.intron.id == g)
  start <- intron.info.no.intron.with.nearby$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)

intron.one.for.stats.nearby <- intron.info.no.intron.with.nearby[res,]
intron.one.for.stats.nearby <- data_frame(chr = intron.one.for.stats.nearby$chr.x,
                                          start = intron.one.for.stats.nearby$intron.start,
                                          end = intron.one.for.stats.nearby$intron.end,
                                          strand = intron.one.for.stats.nearby$gene.strand,
                                          ids = intron.one.for.stats.nearby$intron.id,
                                          gene.id = intron.one.for.stats.nearby$no.intron.id,
                                          type = rep("intron_one_nearby", nrow(intron.one.for.stats.nearby)),
                                          gene.strand = intron.one.for.stats.nearby$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(intron.one.for.stats.nearby)),
                                          tRNAFirst = rep("NA", nrow(intron.one.for.stats.nearby)),
                                          tRNA.upstream = rep("NA", nrow(intron.one.for.stats.nearby)))

# range for 2nd closest intron to intergenic 
res <- lapply(list.gene.id.nearby,function(g){
  rowNb <- which(intron.info.no.intron.with.nearby$no.intron.id == g)
  start <- intron.info.no.intron.with.nearby$intron.start[rowNb]
  or <- order(start)
  c(rowNb[or==2]) 
}) 
res <- unlist(res)

intron.two.for.stats.nearby <- intron.info.no.intron.with.nearby[res,]
intron.two.for.stats.nearby <- data_frame(chr = intron.two.for.stats.nearby$chr.x,
                                              start = intron.two.for.stats.nearby$intron.start,
                                              end = intron.two.for.stats.nearby$intron.end,
                                              strand = intron.two.for.stats.nearby$gene.strand,
                                              ids = intron.two.for.stats.nearby$intron.id,
                                              gene.id = intron.two.for.stats.nearby$no.intron.id,
                                              type = rep("intron_two_nearby", nrow(intron.two.for.stats.nearby)),
                                              gene.strand = intron.two.for.stats.nearby$gene.strand,
                                              length = end-start+1,
                                              sameStrand = rep("NA", nrow(intron.two.for.stats.nearby)),
                                              tRNAFirst = rep("NA", nrow(intron.two.for.stats.nearby)),
                                              tRNA.upstream = rep("NA", nrow(intron.two.for.stats.nearby)))

# combine info together for closest and 2nd closest intron
intron.one.nearby <- intron.one.for.stats.nearby %>% 
  arrange(gene.id) %>% 
  unique()%>% group_by(ids) %>% slice_min(n = 1, gene.id)%>% #some condidate genes can share same nearby gene, we can only count one time and assign the average coverage to the candidate genes
    ungroup()
intron.two.nearby <- intron.two.for.stats.nearby %>% 
  arrange(gene.id) %>% 
  unique()%>% group_by(ids) %>% slice_min(n = 1, start)%>%
    ungroup()%>% group_by(ids) %>% slice_min(n = 1, gene.id)%>%
    ungroup()

# put everything together for calculate average coverage (AC)

final.stats.info.no.intron.nearby <- do.call("rbind", list(intron.one.nearby,
                                          intron.two.nearby,
                                          intergenic.info)) %>%
  arrange(gene.id)
```
#build bed file for nearby intron 1 and 2 
```{r}
#Nearby intron 1
no.intron.nearby.intron1.bed <- intron.one.nearby %>%
   dplyr::select(chr, start, end, ids) %>%
    dplyr::mutate(start = start - 1) %>%
  na.omit()
 #output the file
 write.table(no.intron.nearby.intron1.bed,
             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/no_intron_nearby_intron1.bed",
             quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
#Nearby intron 2
no.intron.nearby.intron2.bed <- intron.two.nearby %>%
   dplyr::select(chr, start, end, ids) %>%
    dplyr::mutate(start = start - 1)
 #output the file
 write.table(no.intron.nearby.intron2.bed,
             file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Essential_files/no_intron_nearby_intron2.bed",
             quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
```
## Count reads for intergenic, intron 1 and 2 bed file from your RNA seq bam files 
for i in {22672685..22672687}; do
  samtools depth -@ 30 -b no_intron_nearby_intron1.bed -a "SRR${i}_.sorted.bam" > "Cov_SRR${i}_no_intron_nearby_intron1.txt"
  samtools depth -@ 30 -b no_intron_nearby_intron2.bed -a "SRR${i}_.sorted.bam" > "Cov_SRR${i}_no_intron_nearby_intron2.txt"
done
##load depth count from SAMtools 
```{r}
#mimic intron1 
no_intron_Nearby_intron1_coverage_SRR22672685 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672685_no_intron_nearby_intron1.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
no_intron_Nearby_intron1_coverage_SRR22672686 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672686_no_intron_nearby_intron1.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
no_intron_Nearby_intron1_coverage_SRR22672687 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672687_no_intron_nearby_intron1.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
#mimic intron 2 
no_intron_Nearby_intron2_coverage_SRR22672685 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672685_no_intron_nearby_intron2.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
no_intron_Nearby_intron2_coverage_SRR22672686 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672686_no_intron_nearby_intron2.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
no_intron_Nearby_intron2_coverage_SRR22672687 <- read.table("E:/Barley/PRJNA910827/Cov_SRR22672687_no_intron_nearby_intron2.txt", header = FALSE, col.names = c("chr", "position", "coverage"))
```
## use summaruze mean for coverage of intron mimic
```{r, coverage of intron mimic}
###Intron1
Coverage_no_intron_Nearby_intron1_SRR22672685 <- no_intron_Nearby_intron1_coverage_SRR22672685 %>%
  left_join(intron.one.nearby, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_no_intron_Nearby_intron1_SRR22672686 <- no_intron_Nearby_intron1_coverage_SRR22672686 %>%
  left_join(intron.one.nearby, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_no_intron_Nearby_intron1_SRR22672687 <- no_intron_Nearby_intron1_coverage_SRR22672687 %>%
  left_join(intron.one.nearby, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

#Get average coverage into new column
AC_no_intron_Nearby_intron1_SRR22672685 <- Coverage_no_intron_Nearby_intron1_SRR22672685 %>%
  group_by(ids) %>%
  summarize(SRR22672685_AveCov = mean(coverage)) %>%
  mutate(SRR22672685_AveCov = as.numeric(sprintf("%.7f", SRR22672685_AveCov))) %>%
  ungroup()

AC_no_intron_Nearby_intron1_SRR22672686 <- Coverage_no_intron_Nearby_intron1_SRR22672686 %>%
  group_by(ids) %>%
  summarize(SRR22672686_AveCov = mean(coverage)) %>%
  mutate(SRR22672686_AveCov = as.numeric(sprintf("%.7f", SRR22672686_AveCov))) %>%
  ungroup()

AC_no_intron_Nearby_intron1_SRR22672687 <- Coverage_no_intron_Nearby_intron1_SRR22672687 %>%
  group_by(ids) %>%
  summarize(SRR22672687_AveCov = mean(coverage)) %>%
  mutate(SRR22672687_AveCov = as.numeric(sprintf("%.7f", SRR22672687_AveCov))) %>%
  ungroup()

###Intron2
Coverage_no_intron_Nearby_intron2_SRR22672685 <- no_intron_Nearby_intron2_coverage_SRR22672685 %>%
  left_join(intron.two.nearby, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_no_intron_Nearby_intron2_SRR22672686 <- no_intron_Nearby_intron2_coverage_SRR22672686 %>%
  left_join(intron.two.nearby, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

Coverage_no_intron_Nearby_intron2_SRR22672687 <- no_intron_Nearby_intron2_coverage_SRR22672687 %>%
  left_join(intron.two.nearby, by = c("chr" = "chr")) %>%
  filter(position >= start, position <= end) %>%
  select(ids, chr, position, coverage)

#Get average coverage into new column
AC_no_intron_Nearby_intron2_SRR22672685 <- Coverage_no_intron_Nearby_intron2_SRR22672685 %>%
  group_by(ids) %>%
  summarize(SRR22672685_AveCov = mean(coverage)) %>%
  mutate(SRR22672685_AveCov = as.numeric(sprintf("%.7f", SRR22672685_AveCov))) %>%
  ungroup()

AC_no_intron_Nearby_intron2_SRR22672686 <- Coverage_no_intron_Nearby_intron2_SRR22672686 %>%
  group_by(ids) %>%
  summarize(SRR22672686_AveCov = mean(coverage)) %>%
  mutate(SRR22672686_AveCov = as.numeric(sprintf("%.7f", SRR22672686_AveCov))) %>%
  ungroup()

AC_no_intron_Nearby_intron2_SRR22672687 <- Coverage_no_intron_Nearby_intron2_SRR22672687 %>%
  group_by(ids) %>%
  summarize(SRR22672687_AveCov = mean(coverage)) %>%
  mutate(SRR22672687_AveCov = as.numeric(sprintf("%.7f", SRR22672687_AveCov))) %>%
  ungroup()
```
###Make 3 samples into one dataframe
```{r}
#no_intron_mimic_intron1
AC_no_intron_Nearby_intron1 <- AC_no_intron_Nearby_intron1_SRR22672685 %>%
  left_join(AC_no_intron_Nearby_intron1_SRR22672686, by = "ids") %>%
  left_join(AC_no_intron_Nearby_intron1_SRR22672687, by = "ids")
#no_intron_mimic_intron2
AC_no_intron_Nearby_intron2 <- AC_no_intron_Nearby_intron2_SRR22672685 %>%
  left_join(AC_no_intron_Nearby_intron2_SRR22672686, by = "ids") %>%
  left_join(AC_no_intron_Nearby_intron2_SRR22672687, by = "ids")
```

```{r}
# gethering Average Coverage data for t-test
AC.nearby.final <- do.call("rbind", list(AC_intergenic_no_intron,
                                  AC_no_intron_Nearby_intron1,
                                  AC_no_intron_Nearby_intron2))
```
## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(no.intron.info, intron.one.for.stats.nearby, by = "gene.id")
intron1.nearby.data <- data_frame(chr = x1$chr.y,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.y,
                                     id = x1$id,
                                     type = x1$type,
                                     length = x1$length.y,
                                     sameStrand = x1$sameStrand.y,
                                     tRNAFirst = x1$tRNAFirst.y,
                                     tRNA.upstream = x1$tRNA.upstream.y) %>%
  na.omit()

x1 <- merge(no.intron.info, intron.two.for.stats.nearby, by = "gene.id")
intron2.nearby.data <- data_frame(chr = x1$chr.y,
                                       start = x1$start,
                                       end = x1$end,
                                       ids = x1$ids,
                                       gene.id = x1$gene.id,
                                       strand = x1$gene.strand.y,
                                       id = x1$id,
                                       type = x1$type,
                                       length = x1$length.y,
                                       sameStrand = x1$sameStrand.y,
                                       tRNAFirst = x1$tRNAFirst.y,
                                       tRNA.upstream = x1$tRNA.upstream.y) %>%
  na.omit()

# put everything togeher
final.stats.parid.intron.nearby <- do.call("rbind", list(intron1.nearby.data,
                                           intron2.nearby.data,
                                           intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
final.stats.test.intron.nearby <- final.stats.parid.intron.nearby %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length)

aveCoverage.all.intron.nearby <- AC.nearby.final %>%
  left_join(final.stats.test.intron.nearby, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final.intron.nearby <- aveCoverage.all.intron.nearby %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_data_frame() %>%  arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene.intron.nearby <- aveCoverage.final.intron.nearby %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 2 elements with different comparison and do the t.test
tTestResults.final.intron.nearby <- tRnaToGene.intron.nearby$ids %>% 
  # extract(1) %>% #extract 1 candidate and have a look
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene.intron.nearby, ids ==x)$id
    cov <- filter(aveCoverage.final.intron.nearby, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )
    
    # Compare the introns
    if (all(c("intron_two_nearby", "intron_one_nearby") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_one_nearby"]+1),
                      log(cov[,"intron_two_nearby"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intron_two_nearbyVsintron_one_nearby",
                     df = tTest$parameter, # degree of freedom
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    
    # Compare the intergenic regions
    if (all(c("intergenic", "intron_one_nearby") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_one_nearby"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intergenicVsintron_one_nearby",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## t.test output
```{r two way filtering}
# for FDR
intergeic.sign.final.intron.nearby <- tTestResults.final.intron.nearby$intergenicVsintron_one_nearby %>% filter(FDR < 0.05, V < 0) 
intron.not.sign.final.intron.nearby <- tTestResults.final.intron.nearby$intron_two_nearbyVsintron_one_nearby %>% filter((FDR < 0.05 & V > 0) | FDR >=0.05)
final.sign.intron.nearby <- intersect(intron.not.sign.final.intron.nearby$id,intergeic.sign.final.intron.nearby$id)
#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
#intron.not.sign.final <- tTestResults.final$Intron2VsIntron1 %>% 
 # filter((adjP < 0.05 & V > 0) | adjP >=0.05) 
#final.sign.adjP <- intersect(intron.not.sign.final$id,intergeic.sign.final$id) 
```
###filter ids that overlapped with two methods
```{r}
final.sign.no.intron.overlap <- intersect(final.sign.no.intron,final.sign.intron.nearby)
```
## assess continuous coverage for candidates with no intron that pass the t.test with both methods
```{r}
coverage.list.final.no.intron <- nZero.intergenic %>%
  merge(final.stats.parid, by = "ids") %>% 
 filter(id %in% final.sign.no.intron.overlap) %>%
  mutate(continu.cov = rowSums(dplyr::select(., contains("nZero"))) == 0)

# make all coverage data addable for each sample and assess the continious Cov for combined coverage
keptIntergenic.no.intron <- coverage.list.final.no.intron$ids
coverage.samples.final.no.intron <- Coverage_intergenic_SRR22672685 %>%
  left_join(Coverage_intergenic_SRR22672686, by = "position") %>%
  left_join(Coverage_intergenic_SRR22672687, by = "position") %>%  
  dplyr::select(ids, position, SRR22672685_Cov, SRR22672686_Cov, SRR22672687_Cov) %>%
  filter(ids %in% keptIntergenic.no.intron)

combined.nZero.no.intron <- coverage.samples.final.no.intron %>%
  group_by(ids) %>%
  summarize(Combined.nZero = sum(SRR22672685_Cov == 0 & SRR22672686_Cov == 0 & SRR22672687_Cov == 0))

continuous.coverage.final.no.intron <- left_join(coverage.list.final.no.intron,combined.nZero.no.intron, by = "ids") %>%
  mutate(Combined.nZero = Combined.nZero == 0) %>%
  setnames("Combined.nZero", "combined.continu.cov")
```
# export results
```{r}
write.table(continuous.coverage.final.no.intron,
            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Result/Barley827_Result_with_no_intron.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
```
#put results from three types(two and more introns, one intron, no intron) together
```{r}
continuous.coverage.final.all <-rbind(continuous.coverage.final,
                                       #continuous.coverage.final.one.intron,
                                        continuous.coverage.final.no.intron) %>%
 filter(combined.continu.cov == TRUE) %>%
  unique()
```
#estimate if the tRNA is in UTR: tRNA overlap with CDS has been filtered out by bedtools closest. Therefore I can get the full gene start end coordinate. Then, I need to find if the tRNA in dicistronic tRNA:CDS transcripts are overlap with the coresponding gene.
```{r}
# combine continuous.coverage.final.all with tRNA coordinates
Dicistronic.all.tRNA <- left_join(continuous.coverage.final.all,tRNA.CDS.expressed.combo, by ="id") %>%
   dplyr::select(id, chr.x, start, end, gene.id.x, gene.start, gene.end, gene.strand, tRNA.id, tRNA.start, tRNA.end, tRNA.strand, tRNA.upstream.x, tRNAFirst.x, interval.length, continu.cov, combined.continu.cov) %>%
  set_colnames(c("id", "chr", "start", "end", "gene.id", "gene.start", "gene.end", "gene.strand", "tRNA.id", "tRNA.start", "tRNA.end", "tRNA.strand", "tRNA.upstream", "tRNAFirst", "interval.length", "continu.cov", "combined.continu.cov"))
#Remember that until now the gene start and end in dicistronic information are CDS start end coordinate, not the real gene start/end coordinate. I will make real gene coordinate underneath.
gene.info <- getBM(attributes=c("chromosome_name", "start_position", "end_position",
                                "ensembl_gene_id", "strand", "gene_biotype"), mart=m)  %>%
  set_colnames(c("gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand", "gene.biotype")) %>%
  mutate(#gene.chr = paste0('chr', gene.chr),
         gene.strand = ifelse(gene.strand == 1,"+","-")) %>%  # make it consistant with other data for strand symbol and Chr names, if the format alread matched, this line of code needs to set as comment 
  arrange(gene.chr, gene.start)

gene.info.sorted <- gene.info %>%
  filter(gene.biotype == "protein_coding") %>% # keep the type of annotation that you are interested to explore
  arrange(gene.chr, gene.start) 
Dicistronic.gene <- gene.info.sorted %>% filter(gene.id %in% continuous.coverage.final.all$gene.id) %>% unique()

# estimate if tRNA overlaps with UTR. In Dicistronic.tRNA.gene.coordinate, gene.start.x is gene without UTR, y is with UTR, so we use gene.start.y
Dicistronic.tRNA.gene.coordinate <- left_join(Dicistronic.all.tRNA, Dicistronic.gene, by = "gene.id") %>%
  dplyr::select(id, chr, start, end, gene.id, gene.start.y, gene.end.y, gene.strand.x, tRNA.id, tRNA.start, tRNA.end, tRNA.strand, tRNA.upstream, tRNAFirst, interval.length, continu.cov, combined.continu.cov) %>%
  set_colnames(c("id", "chr", "start", "end", "gene.id", "gene.start", "gene.end", "gene.strand", "tRNA.id", "tRNA.start", "tRNA.end", "tRNA.strand", "tRNA.upstream", "tRNAFirst", "interval.length", "continu.cov", "combined.continu.cov")) %>%  mutate(tRNA.overlap.UTR = ifelse(tRNAFirst == 'TRUE' & gene.start < tRNA.end, TRUE,
                                    ifelse(tRNAFirst == 'FALSE'& gene.end > tRNA.start, "TRUE","FALSE" ))) %>%
  dplyr::select(id, chr, start, end, gene.id, gene.start, gene.end, gene.strand, tRNA.id, tRNA.start, tRNA.end, tRNA.strand, tRNA.upstream, tRNAFirst, interval.length, continu.cov, combined.continu.cov, tRNA.overlap.UTR)
tRNA.UTR.final <- table(Dicistronic.tRNA.gene.coordinate$tRNA.overlap.UTR == "TRUE")

tRNA_in_UTR_all <- data.frame(
  "tRNA.UTR.tgene.combo" = tRNA.UTR.tgene.combo,
  "tRNA.UTR.tgene.expressed.combo" = tRNA.UTR.tgene.expressed.combo,
  "tRNA.UTR.final" = tRNA.UTR.final
)
```
# export results
```{r}
write.table(tRNA_in_UTR_all,
            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Result/Barley827_tRNA_in_UTR_all.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
write.table(Dicistronic.tRNA.gene.coordinate,
            file = "C:/AAAStudy/PhD/Bioinformatics/Phylogenetic/Barley/Result/Barley827_Final_Result.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
```
