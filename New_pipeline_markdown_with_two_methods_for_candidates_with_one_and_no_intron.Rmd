---
title: "DiRT_PN/Mgt"
output: html_document
date: "2023-01-12"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Setup

```{r}
library(GenomicRanges)
library(GenomicAlignments)
library(GenomicFeatures)
library(rtracklayer)
library(magrittr)
library(plyr)
library(reshape2)
library(tidyverse)
library(biomaRt)
library(Rsamtools)
library(data.table)
library(GeneOverlap)
```
## Step1: fine tRNA-gene combination from reference genome
# construct proper gene list for anaylsis
```{r}
gene.info.from.gff <- read_delim("C:/AAAStudy/PhD/Bioinformatics/GrapeGenomeRef/Vitis_vinifera.PN40024.v4.55.gff3", delim = "\t", col_names = FALSE) %>%
  dplyr::select(X1,X4,X5,X9,X7,X3) %>%
  set_colnames(c("gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand", "gene.biotype")) %>%
  #mutate(#gene.chr = paste0('chr', gene.chr),
  #       gene.strand = ifelse(gene.strand == 1,"+","-")) %>%  # make it consistant with other data for strand symbol and Chr names, if the format alread matched, this line of code needs to set as comment 
  arrange(gene.chr, gene.start)
CDS.info.sorted <- gene.info.from.gff %>%
  filter(gene.biotype == "CDS") %>% # keep the type of annotation that you are interested to explore
  mutate(gene.id = sub(".*protein_id=", "",gene.id))%>%
  mutate(gene.id = sub("_P.*", "",gene.id)) %>%
  arrange(gene.chr, gene.start)
CDS.start.point <-  CDS.info.sorted %>% dplyr::select("gene.chr", "gene.start", "gene.id", "gene.strand", "gene.biotype") %>% group_by(gene.id) %>% slice_min(n = 1, gene.start)%>%
  arrange(gene.chr, gene.start)
CDS.end.point <-  CDS.info.sorted %>% dplyr::select("gene.chr", "gene.end", "gene.id", "gene.strand", "gene.biotype") %>% group_by(gene.id) %>% slice_max(n = 1, gene.end)%>%
  arrange(gene.chr, gene.end)
CDS.start.end.for.gene <- left_join(CDS.start.point, CDS.end.point, by = "gene.id")%>% dplyr::select("gene.chr.x", "gene.start", "gene.end", "gene.id", "gene.strand.x", "gene.biotype.x") %>%
  set_colnames(c("gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand", "gene.biotype"))
  
# output the gene info for bedtools use
write.table(CDS.start.end.for.gene,
            file = "C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/CDS.start.end.for.gene.txt",
            quote = FALSE, sep = "\t",
            row.names = FALSE, col.names = FALSE)

# tRNA info from GtRNA database
tRNA.info <- read_delim("C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/vitVin1-tRNAs/vvPN4unmasktest.bed", delim = "\t", col_names = FALSE) %>%
  dplyr::select(X1:X4, X6) %>%
  set_colnames(c("tRNA_chr", "tRNA_start", "tRNA_end", "tRNA_id","tRNA_strand")) %>%
  #mutate(tRNA_chr = paste0('chr', tRNA_chr)) %>%
  arrange(tRNA_chr, tRNA_start)
  
# output the tRNA info for bedtools use
write.table(tRNA.info,
            file = "C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/vvtRNAsnew_sorted.txt",
            quote = FALSE, sep = "\t",
            row.names = FALSE, col.names = FALSE)
```
##  find closeest gene to an tRNA for both behind and after by ```BEDTools``` on Phoenix HPC terminal
#Before start, the genome file might needed. This information can be pull out from any target dataset `bam` file header. This should be done on R studio and upload the 'Vv_genome.txt' into HPC folder 
```{r}
seq.size <- BamFile("F:/Fei/Master/Pastor_folder/Newalignedmergeddata/EE1.sorted.merged.bam") %>%  ##this bam file can be any name
  seqinfo() %>% 
  as.data.frame() %>% 
  mutate(sequence =rownames(.)) %>% 
  dplyr::select(sequence, seqlengths) %>% 
  arrange(sequence)

# output the genome file for bedtools use
write.table(seq.size,
            file = "C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/Vv_genomeEEberry.txt",
            quote = FALSE, sep = "\t",
            row.names = FALSE, col.names = FALSE)
```

## Step2: find closeest gene to an tRNA for both behind and after by BEDTools on Phoenix HPC terminal. 
Using ignore up/down stream (-iu/id) options is to make sure all tRNA can find genes associated with either up or down stream of the tRNA.
# the .txt files are Windows-style CR-LF line endings. use notepad++ Edit>EOL conversion>Unix to fix them or use this code in HPC on every txt files:
awk '{ sub("\r$", ""); print }' Vv_genome.txt > Vv_genomephn.txt

module load BEDTools

bedtools closest -id -a vvtRNAsnew_sorted.txt -b CDS.start.end.for.gene.txt -g Vv_genomeEEberry.txt -D ref > closest_tRNA_CDS_upS.bed
bedtools closest -iu -a vvtRNAsnew_sorted.txt -b CDS.start.end.for.gene.txt -g Vv_genomeEEberry.txt -D ref > closest_tRNA_CDS_downS.bed

## combine two result files from BedTools and sort, then refine info into proper format
```{r}
closest_tRNA_CDS.up <- read.delim("C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/closest_tRNA_CDS_upS.bed", header=FALSE)
closest_tRNA_CDS.down <- read.delim("C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/closest_tRNA_CDS_downS.bed", header=FALSE)

closest_tRNA_CDS <- rbind(closest_tRNA_CDS.up,closest_tRNA_CDS.down) %>% 
  unique() %>% 
  set_colnames(c("chr", "tRNA.start", "tRNA.end", "tRNA.id", "tRNA.strand",
                 "gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand",
                 "gene.biotype", "distance")) %>%
  dplyr::select(-gene.chr) %>%
  mutate(tRNAFirst = tRNA.start < gene.start,
         tRNA.upstream = ifelse(gene.strand == '+' & distance > 0, TRUE,
                                ifelse(gene.strand == '-' & distance < 0, TRUE, FALSE)),
         interval.length = ifelse(tRNAFirst == TRUE, 
                                  (gene.start-1)-(tRNA.end+1)+1, (tRNA.start-1)-(gene.end+1)+1))
```
## subset proper distance (not overlapped) for tRNA-gene combination and add unique id to them
#This pipeline is designed for non-stranded library, so only non-overlapped tRNA-gene combinations are considered as input. tRNA or gene id stand itself may cause issue for one match many, therefore, unique combination id is created.
```{r}
tRNA.CDS.combo <- closest_tRNA_CDS %>% 
  filter(distance != 0) %>%
  filter(interval.length != 0) %>%
  mutate(tRNA.id = as.character(tRNA.id),
         gene.id = as.character(gene.id)) %>% 
  split(f = seq(1, nrow(.))) %>% # break up the dataframe to one col one dataframe 
  lapply(function(x){mutate(x, id = paste(sort(c(x$tRNA.id, x$gene.id)), collapse = "_"))}) %>%
  bind_rows() %>% group_by(gene.id) %>% slice_min(n = 1, interval.length)%>%
    ungroup()
```
# filter commonly expressed tRNA and gene 
## setup the bundary for the whole genome (safty net!)
```{r}
Seqinfo <- read_delim("C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/Vv_genomeEEberry.txt", 
                      delim = "\t", col_names = FALSE) %>%
  set_names(c("seqnames", "seqlengths"))

Seqinfo <- with(Seqinfo,
                Seqinfo(seqnames = seqnames,
                        seqlengths = seqlengths,
                        isCircular = rep(FALSE, length(seqnames)),
                        genome = "genomeBuild")) %>%
  sortSeqlevels()

#if I modified the vv-tRNA.txt and vv_whole_genome_sort.txt outside of R (for example using Excel or HPC) i need to regenerate tRNA infor and gene infor as edited version

#tRNA.info <- read_delim("C:/AAAStudy/PhD/Bioinformatics/testpipelinewitholdref/Essentail_file/Ruggeri_tRNAs_sorted.txt", delim = #"\t", col_names = FALSE) %>%
#  set_colnames(c("tRNA_chr", "tRNA_start", "tRNA_end", "tRNA_id","tRNA_strand"))

#gene.info.sorted <- read_delim("C:/AAAStudy/PhD/Bioinformatics/testpipelinewitholdref/Essentail_file/Ruggerie_whole_genome_detaile#d_sorted.txt", delim = "\t", col_names = FALSE) %>%
#  set_colnames(c("gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand", "gene.biotype"))
```

## build up the ```GRange``` by ```makeGRangesFromDataFrame``` for tRNA
```{r}
GRange_tRNA <- makeGRangesFromDataFrame(tRNA.info,
                                        keep.extra.columns = TRUE,
                                        ignore.strand = FALSE,
                                        seqinfo = Seqinfo,
                                        seqnames.field = "tRNA_chr",
                                        start.field = "tRNA_start",
                                        end.field = "tRNA_end",
                                        strand.field = "tRNA_strand",
                                        starts.in.df.are.0based = FALSE)
```
## Count reads for each tRNA GRange from your RNA seq bam files 
```{r}
# specify Samples
bam.dir <- "F:/Fei/Master/Pastor_folder/Newalignedmergeddata/" # Dir for bamfiles 
bamfiles <- list.files(bam.dir, pattern=".bam$", full.names = TRUE)

#SampleName <- paste0("Sample_",str_extract(basename(bamfiles),"^[0-9]+")) 
SampleName <- basename(bamfiles)
# differdent str_extract pattern will be applied according to your bam names

counts <- lapply (bamfiles,function(bamfile){
  baifile <- paste0(bamfile,".bai")
  bam.input <- readGAlignments(bamfile,
                               index = baifile,
                               use.names = TRUE,
                               param = ScanBamParam(which = GRange_tRNA))
  
  countOverlaps(GRange_tRNA, bam.input,
                maxgap=0L, minoverlap=1L,
                type=c("any"),
                select=c("all"),
                ignore.strand=TRUE)
})


names(counts) <- SampleName
counts <- do.call(cbind,counts)
tRNA.counts <- cbind(tRNA.info,counts)
```
## filter commonly expressed tRNA 
```{r}
# filter expressed tRNA 
# filter needs to be defined according to your dataset. Here, the requirement is at least one read align to this tRNA and reads alignment commonly presents at least in 6 samples 
tRNA.expressed.AllSample <- rowSums(dplyr::select(tRNA.counts,6:9) >= 1) == 4 
# return logical value for all read count column
sum(tRNA.expressed.AllSample) 
common.tRNA <- tRNA.counts[tRNA.expressed.AllSample,]
tRNA.expressed.CDS.combo <- filter(tRNA.CDS.combo, tRNA.id %in% common.tRNA$tRNA_id) 
#131 
```
## build up the ```GRange``` by ```makeGRangesFromDataFrame``` for gene
```{r}
# prepare gene data
gene.counts <- tRNA.expressed.CDS.combo %>%
  dplyr::select(chr, gene.start, gene.end, gene.id, gene.strand) %>%
  unique()

# build up GRange for the gene
GRange_gene <- makeGRangesFromDataFrame(gene.counts,
                                        keep.extra.columns = TRUE,
                                        ignore.strand = TRUE,
                                        seqinfo = Seqinfo,
                                        seqnames.field = "chr",
                                        start.field = "gene.start",
                                        end.field = "gene.end",
                                        strand.field = "gene.strand",
                                        starts.in.df.are.0based = FALSE)
```
## Count reads for each gene GRange from ```bam``` files. Take more than 2 hours, try bioparalle package.
```{r}
counts <- lapply (bamfiles,function(bamfile){
  baifile <- paste0(bamfile,".bai")
  bam.input <- readGAlignments(bamfile,
                               index = baifile,
                               use.names = TRUE,
                               param = ScanBamParam(which = GRange_gene))
  
  countOverlaps(GRange_gene, bam.input,
                maxgap=0L, minoverlap=1L,
                type=c("any"),
                select=c("all"),
                ignore.strand=TRUE)
})
names(counts) <- SampleName
counts <- do.call(cbind,counts)
gene.counts <- cbind(gene.counts,counts)
```
## filter commonly expressed gene
```{r}
# filter expressed gene 
gene.expressed.AllSample <- rowSums(dplyr::select(gene.counts, 6:9) >= 1) == 4 # same requirement as above 
sum(gene.expressed.AllSample) 
common.gene <- gene.counts[gene.expressed.AllSample,]
tRNA.CDS.expressed.combo <- filter(tRNA.expressed.CDS.combo, gene.id %in% common.gene$gene.id)

#86
```
####How many candidates in tRNA.CDS.expressed.combo has no intron or one intron:
#extract exon information from plant ensembl
```{r}
# To choose BioMart database and construct information needed
listMarts(host="plants.ensembl.org")
useMart("plants_mart", host="plants.ensembl.org") %>% listDatasets()

# Choose data types you want to download
m <- useMart("plants_mart", dataset="vvinifera_eg_gene", host="plants.ensembl.org")
attrib <- listAttributes(m) # search any attributes that you think might be useful
```

```{r}
# define input.data
input.data <- tRNA.CDS.expressed.combo
# pull out the exon and UTR information from embl plants
exon.info <- getBM(attributes=c("chromosome_name", "exon_chrom_start", "exon_chrom_end", 
                                "ensembl_exon_id","ensembl_gene_id", "strand"), mart=m) %>%
  set_colnames(c("chr","start","end","exon_UTR_id","gene.id","gene.strand")) %>%
  filter(gene.id %in% input.data$gene.id) %>%
  mutate(#chr = paste0('chr', chr),
         gene.strand = ifelse(gene.strand == 1,"+","-"))
```
#get how many tRNA.gene.expressed.combo have no intron
```{r}
### filter positive result with only 1 exon (no intron)
tgene.expressed.exon <- exon.info %>% separate(col ="exon_UTR_id", sep = ".e", into=c("transcript.id","exon_UTR_id")) %>% mutate("exon_UTR_id" = paste0('e', exon_UTR_id))

tgene.expressed.exon2 <- tgene.expressed.exon  %>% filter(`exon_UTR_id` == "exon2")

tgene.only.one.exon <- subset(tgene.expressed.exon , !(gene.id %in% tgene.expressed.exon2$gene.id))

#17 candidates with no intron in EEberry tRNA gene expressed

#write.table(tgene.only.one.exon,
 #           file = "C:/AAAStudy/PhD/Bioinformatics/Ruggeri/Results/Rugg_tGene_expressed_on#e_exon.xlsx",
 #           quote = FALSE, sep = "\t", row.names = FALSE)

### filter positive result with only 2 exon (one intron)

tgene.expressed.exon3 <- tgene.expressed.exon %>% filter(`exon_UTR_id` == "exon3")
tgene.expressed.with1and2exon <- subset(tgene.expressed.exon, !(gene.id %in% tgene.expressed.exon3$gene.id)) 
tgene.expressed.with2exon <-  subset(tgene.expressed.with1and2exon, !(gene.id %in% tgene.only.one.exon$gene.id))  %>% filter(`exon_UTR_id` == "exon2")

#write.table(tgene.expressed.with2exon,
#            file = "C:/AAAStudy/PhD/Bioinformatics/Ruggeri/Results/Rugg_tGene_expressed_tw#o_exon.xlsx",
#            quote = FALSE, sep = "\t", row.names = FALSE)

#15 with 2 exon (one intron) in EEberry tRNA gene expressed
```

```{r}
#===============================================================================#

UTR5.gene.info <- getBM(attributes=c("chromosome_name", "5_utr_start", "5_utr_end", 
                                "ensembl_gene_id","ensembl_gene_id", "strand", "start_position", "end_position"), mart=m)

UTR5.info <- getBM(attributes=c("chromosome_name", "5_utr_start", "5_utr_end", 
                                "ensembl_gene_id","ensembl_gene_id", "strand"), mart=m)%>%
  set_colnames(c("chr","start","end","exon_UTR_id","gene.id","gene.strand")) %>%
  filter(gene.id %in% input.data$gene.id) %>%
  mutate(#chr = paste0('chr', chr),
         gene.strand = ifelse(gene.strand == 1,"+","-"),
         `exon_UTR_id` = paste0(`exon_UTR_id`,".5_UTR")) %>%
  na.omit() %>%
  arrange(chr,start)

# give unique numbers to UTRs that are belongs to same genes
UTR.num <- sapply(as.character(unique(UTR5.info$gene.id)), function(g){
  rowNb <- which(g == UTR5.info$gene.id)
  strand <- UTR5.info$gene.strand[rowNb]
  start <- UTR5.info$start[rowNb]
  order(ifelse(strand =="+", start, -start))
}) %>% unlist()
UTR5.info %<>% mutate(`exon_UTR_id` = paste0(`exon_UTR_id`,".",UTR.num))

#===============================================================================#

UTR3.gene.info <- getBM(attributes=c("chromosome_name", "3_utr_start", "3_utr_end", 
                                "ensembl_gene_id","ensembl_gene_id", "strand", "start_position", "end_position"), mart=m)
UTR3.info <- getBM(attributes=c("chromosome_name", "3_utr_start", "3_utr_end", 
                                "ensembl_gene_id","ensembl_gene_id", "strand"), mart=m)%>%
  set_colnames(c("chr","start","end","exon_UTR_id","gene.id","gene.strand")) %>%
  filter(gene.id %in% input.data$gene.id) %>%
  mutate(#chr = paste0('chr', chr),
         gene.strand = ifelse(gene.strand == 1,"+","-"),
         `exon_UTR_id` = paste0(`exon_UTR_id`,".3_UTR")) %>%
  na.omit() %>%
  arrange(chr,start)

UTR.num <- sapply(as.character(unique(UTR3.info$gene.id)), function(g){
  rowNb <- which(g == UTR3.info$gene.id)
  strand <- UTR3.info$gene.strand[rowNb]
  start <- UTR3.info$start[rowNb]
  order(ifelse(strand =="+", start, -start))
}) %>% unlist()
UTR3.info %<>% mutate(`exon_UTR_id` = paste0(`exon_UTR_id`,".",UTR.num))

# bind them all together and sorted
UTR_exon.info <- rbind(exon.info,
                       UTR5.info,
                       UTR3.info) %>%
  arrange(chr, start, end)
# It looks like the first or last exon embl plants defined acturaly take UTR into a count as a part of it. if UTR info is provided, the intron in the UTR region can be found. otherwise, it returns intron info in the following code as typical intron, which is between two exon is a intron.
# pull out intron coordinates based on the data above
UTR_exon.set1 <- UTR_exon.info %>% 
  dplyr::select(chr,start,end,`exon_UTR_id`,gene.id, gene.strand) %>%
  set_colnames(c("chr","start.set1","end.set1",
                 "exon_UTR_id.set1","gene.id.set1","gene.strand.set1"))

UTR_exon.set2 <- UTR_exon.info[-1,] %>% 
  dplyr::select(start,end,`exon_UTR_id`,gene.id, gene.strand) %>%
  set_colnames(c("start.set2","end.set2",
                 "exon_UTR_id.set2","gene.id.set2","gene.strand.set2")) %>%
  rbind(c(0,0,NA,NA))

intron.info <- cbind(UTR_exon.set1, UTR_exon.set2) %>% #intron.info = tRNA.CDS.expressed.combo - gene candidates without intron (17)
  filter(gene.id.set1 == gene.id.set2 & end.set1 < start.set2) %>%
  dplyr::select(chr, end.set1, start.set2, `exon_UTR_id.set1`, gene.id.set1, gene.strand.set1) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "intron.id","gene.id", "gene.strand")) %>%
  arrange(chr, intron.start) %>%
  mutate(intron.start = intron.start+1,
         intron.end = intron.end-1,
         intron.id = paste0(gene.id, '.intron'))

intron.num <- sapply(as.character(unique(intron.info$gene.id)), function(g){
  rowNb <- which(g == intron.info$gene.id)
  strand <- intron.info$gene.strand[rowNb]
  start <- intron.info$intron.start[rowNb]
  order(ifelse(strand =="+", start, -start))
}) %>% unlist()

intron.info %<>% mutate(intron.id = paste0(intron.id,".", intron.num)) #Candidates without intron will not be included in intron.info
```
# prepare intron coverage data
Here, we had expressed tRNA-gene combination as potential candidates. Now, we need to assess the expression of intron and intergeneic region for each candidates to test if tRNA and gene are co-transcribed.
## Create GRanges to assess the coverage for each sample
### get intergenic and intron1&2 coordinates
```{r}
# keep combination id safe
id <- input.data$id

# get correct intergenic coordinates
intergenic.info <- data_frame(chr = input.data$chr,
                              start = ifelse(input.data$tRNAFirst == TRUE,
                                             input.data$tRNA.end+1,
                                             input.data$gene.end+1),
                              end = ifelse(input.data$tRNAFirst == TRUE,
                                           input.data$gene.start-1,
                                           input.data$tRNA.start-1),
                              strand = rep("NA", nrow(input.data)),
                              ids = input.data$id,
                              gene.id = input.data$gene.id,
                              type = rep("intergenic", nrow(input.data)),
                              gene.strand = input.data$gene.strand,
                              length = end-start+1,
                              sameStrand = input.data$tRNA.strand == input.data$gene.strand,
                              tRNAFirst = input.data$tRNAFirst,
                              tRNA.upstream = input.data$tRNA.upstream)

# get correct intron
# need closest and 2nd closest intron to intergenic
tRNA.up.intergenic <- filter(intergenic.info, 
                             tRNAFirst == TRUE)

tRNA.down.intergenic <- filter(intergenic.info, 
                               tRNAFirst == FALSE)

# corrdinates for closest intron to intergenic for tRNA.up.intergeic 
list.gene.id <- unique(tRNA.up.intergenic$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(intron.info$gene.id == g)
  start <- intron.info$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)

intron.closest.for.stats.up <- intron.info[res,]
intron.closest.for.stats.up <- data_frame(chr = intron.closest.for.stats.up$chr,
                                          start = intron.closest.for.stats.up$intron.start,
                                          end = intron.closest.for.stats.up$intron.end,
                                          strand = intron.closest.for.stats.up$gene.strand,
                                          ids = intron.closest.for.stats.up$intron.id,
                                          gene.id = intron.closest.for.stats.up$gene.id,
                                          type = rep("intron_closest_to_intergenic", nrow(intron.closest.for.stats.up)),
                                          gene.strand = intron.closest.for.stats.up$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(intron.closest.for.stats.up)),
                                          tRNAFirst = rep("NA", nrow(intron.closest.for.stats.up)),
                                          tRNA.upstream = rep("NA", nrow(intron.closest.for.stats.up)))

# range for 2nd closest intron to intergenic 
# if a gene dose not have more than one intron then the intron/intron comprison will be missing
res <- lapply(list.gene.id,function(g){
  rowNb <- which(intron.info$gene.id == g)
  start <- intron.info$intron.start[rowNb]
  or <- order(start)
  c(rowNb[or==2]) 
}) 
res <- unlist(res)

intron.2nd_closest.for.stats.up <- intron.info[res,]
intron.2nd_closest.for.stats.up <- data_frame(chr = intron.2nd_closest.for.stats.up$chr,
                                              start = intron.2nd_closest.for.stats.up$intron.start,
                                              end = intron.2nd_closest.for.stats.up$intron.end,
                                              strand = intron.2nd_closest.for.stats.up$gene.strand,
                                              ids = intron.2nd_closest.for.stats.up$intron.id,
                                              gene.id = intron.2nd_closest.for.stats.up$gene.id,
                                              type = rep("intron_2nd_closest_to_intergenic", nrow(intron.2nd_closest.for.stats.up)),
                                              gene.strand = intron.2nd_closest.for.stats.up$gene.strand,
                                              length = end-start+1,
                                              sameStrand = rep("NA", nrow(intron.2nd_closest.for.stats.up)),
                                              tRNAFirst = rep("NA", nrow(intron.2nd_closest.for.stats.up)),
                                              tRNA.upstream = rep("NA", nrow(intron.2nd_closest.for.stats.up)))

# range for closest intron to intergenic for tRNA.down.intergeic 
list.gene.id <- unique(tRNA.down.intergenic$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(intron.info$gene.id == g)
  start <- intron.info$intron.start[rowNb]
  or <- order(start)
  rowNb[or==max(or)]
}) 
res <- unlist(res)

intron.closest.for.stats.down <- intron.info[res,]
intron.closest.for.stats.down <- data_frame(chr = intron.closest.for.stats.down$chr,
                                            start = intron.closest.for.stats.down$intron.start,
                                            end = intron.closest.for.stats.down$intron.end,
                                            strand = intron.closest.for.stats.down$gene.strand,
                                            ids = intron.closest.for.stats.down$intron.id,
                                            gene.id = intron.closest.for.stats.down$gene.id,
                                            type = rep("intron_closest_to_intergenic", nrow(intron.closest.for.stats.down)),
                                            gene.strand = intron.closest.for.stats.down$gene.strand,
                                            length = end-start+1,
                                            sameStrand = rep("NA", nrow(intron.closest.for.stats.down)),
                                            tRNAFirst = rep("NA", nrow(intron.closest.for.stats.down)),
                                            tRNA.upstream = rep("NA", nrow(intron.closest.for.stats.down)))


# range for 2nd closest intron to intergenic
res <- lapply(list.gene.id,function(g){
  rowNb <- which(intron.info$gene.id == g)
  start <- intron.info$intron.start[rowNb]
  or <- order(start)
  rowNb[or==max(or)-1] 
}) 
res <- unlist(res)

intron.2nd_closest.for.stats.down <- intron.info[res,]
intron.2nd_closest.for.stats.down <- data_frame(chr = intron.2nd_closest.for.stats.down$chr,
                                                start = intron.2nd_closest.for.stats.down$intron.start,
                                                end = intron.2nd_closest.for.stats.down$intron.end,
                                                strand = intron.2nd_closest.for.stats.down$gene.strand,
                                                ids = intron.2nd_closest.for.stats.down$intron.id,
                                                gene.id = intron.2nd_closest.for.stats.down$gene.id,
                                                type = rep("intron_2nd_closest_to_intergenic", nrow(intron.2nd_closest.for.stats.down)),
                                                gene.strand = intron.2nd_closest.for.stats.down$gene.strand,
                                                length = end-start+1,
                                                sameStrand = rep("NA", nrow(intron.2nd_closest.for.stats.down)),
                                                tRNAFirst = rep("NA", nrow(intron.2nd_closest.for.stats.down)),
                                                tRNA.upstream = rep("NA", nrow(intron.2nd_closest.for.stats.down)))


# combine info together for closest and 2nd closest intron
intron.closest <- do.call("rbind", list(intron.closest.for.stats.up,
                                        intron.closest.for.stats.down)) %>% 
  arrange(gene.id) %>% 
  unique()

intron.2nd.closest <- do.call("rbind", list(intron.2nd_closest.for.stats.up,
                                            intron.2nd_closest.for.stats.down)) %>% 
  arrange(gene.id) %>% 
  unique()

# put everything together for calculate average coverage (AC)
intergenic.info %<>% mutate(ids = paste0("intergenic_", ids))

final.stats.info <- do.call("rbind", list(intron.closest,
                                          intron.2nd.closest,
                                          intergenic.info)) %>%
  arrange(gene.id)
```

```{r}
###test if gene without UTR5 are in UTR5.gene.info, also see how many genes in intron.info, delete all objects by rm() later
########underneath is a test code to understand if the intron.info only has tRNA.gene.expressed.combo which have UTR annotation. You do not need to run this chunk in the pipeline
gene.id.final.stats.info <- final.stats.info$gene.id %>% unique()
gene.id.tRNA.CDS <- tRNA.CDS.expressed.combo$gene.id %>% unique()
gene.id.no.intron <- tgene.only.one.exon$gene.id %>% unique()
gene.id.two.intron <- tgene.expressed.exon3$gene.id %>% unique()
gene.id.one.intron <- tgene.expressed.with2exon$gene.id %>% unique()
gene.id.intron.info <- intron.info$gene.id %>% unique()

gene.id.intron.info.not.in.tgene.expreesed.exon3 <- intron.info %>% filter(gene.id %in% tgene.expressed.exon3$gene.id == FALSE)

common.gene.exion.utr5 <- UTR5.info%>%filter(gene.id%in%gene.id.tRNA.CDS)
gene.id.utr5 <- common.gene.exion.utr5$gene.id %>% unique()
#remove everything in this chunk
rm(list = c('gene.id.final.stats.info','gene.id.tRNA.CDS','gene.id.no.intron','gene.id.two.intron','gene.id.one.intron','gene.id.intron.info','gene.id.intron.info.not.in.tgene.expreesed.exon3','common.gene.exion.utr5'))
```
### write intron and intergenic info into ``GRange`` object
```{r}
# intergenic
GRange_intergenic <- intergenic.info %>%
  dplyr::select(chr, start, end, ids, type) %>%
  set_colnames(c("chr", "intergenic.start", "intergenic.end", "ids", "type")) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                           ignore.strand = TRUE,
                           seqinfo = Seqinfo,
                           seqnames.field = "chr",
                           start.field = "intergenic.start",
                           end.field = "intergenic.end",
                           strand.field = NULL,
                           starts.in.df.are.0based = FALSE) 
# intron closest
GRange_intron.closest <- intron.closest %>%
  dplyr::select(chr, start, end, ids, type) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "ids", "type")) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                           ignore.strand = TRUE,
                           seqinfo = Seqinfo,
                           seqnames.field = "chr",
                           start.field = "intron.start",
                           end.field = "intron.end",
                           strand.field = NULL,
                           starts.in.df.are.0based = FALSE) 
# intron 2nd closest
GRange_intron.2nd.closest <- intron.2nd.closest %>%
  dplyr::select(chr, start, end, ids, type) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "ids", "type")) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                           ignore.strand = TRUE,
                           seqinfo = Seqinfo,
                           seqnames.field = "chr",
                           start.field = "intron.start",
                           end.field = "intron.end",
                           strand.field = NULL,
                           starts.in.df.are.0based = FALSE)
```
## use ``Cal_Coverage()`` to look through ``bam`` files for coverage of each base
```{r, coverage of intergenic}
# initialize the function to calculate coverage
Cal_Coverage <- function(gr, bam){
  grl <- split(gr, f = gr$ids)
  cv <- lapply(grl, function(x){
    rng <- seq(start(x), end(x))
    chr <- seqnames(x)
    coverage(bam, param = ScanBamParam(which = x))[[chr]][rng]
  })
  cv
}

# calculate the AverageCoverage and nZero for each sample
coverage.intergenic <- lapply (bamfiles,function(bamfile){
  Cal_Coverage(GRange_intergenic, bamfile)
}) 

names(coverage.intergenic) <- SampleName
DicistronicName <- names(coverage.intergenic$EE1.sorted.merged.bam) 
# give name of dicistronic in order, any sample is ok the order is the same 

# form a proper dataframe for all intergenic AC
AC.nZero.intergenic <- lapply(names(coverage.intergenic), function(x){
  coverage.intergenic[[x]] %>%
    lapply(function(i){
      data.frame(nZero = sum(i == 0), 
                 AveCov = mean(i))}) %>% 
    dplyr::bind_rows() %>% # here is row bind, so the order of these dicisrtronic stays excatly same order as list
    # keep in mind of row order turn from dataframe to list will be changed, so make sure they are constent without missmatching
    set_colnames(c(paste0(x,"_nZero"),paste0(x,"_AveCov"))) 
}) %>%
  dplyr::bind_cols() %>%
  dplyr::mutate(ids = DicistronicName) %>%
  dplyr::select(ids,everything())

AC.intergenic <- AC.nZero.intergenic %>% 
  dplyr::select(ids, contains("AveCov"))

nZero.intergenic <- AC.nZero.intergenic %>% 
  dplyr::select(ids, contains("nZero"))
```

```{r, coverage of intron closest}
# calculate the AC and nZero for each sample
coverage.intron.closest <- lapply (bamfiles,function(bamfile){
  Cal_Coverage(GRange_intron.closest, bamfile)
}) # takes about 4 min for 85 ranges assess 6 bam files

names(coverage.intron.closest) <- SampleName
IntronName <- names(coverage.intron.closest$EE1.sorted.merged.bam) # same as DicistronicName

# form a proper dataframe for all intron closest AC
AC.intron.closest <- lapply(names(coverage.intron.closest), function(x){
  coverage.intron.closest[[x]] %>%
    lapply(function(i){
      data.frame(AveCov = mean(i))}) %>% 
    dplyr::bind_rows() %>%
    set_colnames(paste0(x,"_AveCov"))
}) %>%
  dplyr::bind_cols() %>%
  dplyr::mutate(ids = IntronName) %>%
  dplyr::select(ids, everything())
```

```{r, coverage of intron 2nd closest}
# calculate the AC and nZero for each sample
coverage.intron.2nd.closest <- lapply (bamfiles,function(bamfile){
  Cal_Coverage(GRange_intron.2nd.closest, bamfile)
}) # takes about 4 min for 66 ranges assess 6 bam files

names(coverage.intron.2nd.closest) <- SampleName
IntronName <- names(coverage.intron.2nd.closest$EE1.sorted.merged.bam) # same as DicistronicName

# form a proper dataframe for all intron 2nd.closest AC
AC.intron.2nd.closest <- lapply(names(coverage.intron.2nd.closest), function(x){
  coverage.intron.2nd.closest[[x]] %>%
    lapply(function(i){
      data.frame(AveCov = mean(i))}) %>% 
    dplyr::bind_rows() %>%
    set_colnames(paste0(x,"_AveCov"))
}) %>%
  dplyr::bind_cols() %>%
  dplyr::mutate(ids = IntronName) %>%
  dplyr::select(ids, everything())


# gethering Average Coverage data for t-test
AC.final <- do.call("rbind", list(AC.intergenic,
                                  AC.intron.closest,
                                  AC.intron.2nd.closest))
```

## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(tRNA.up.intergenic, intron.closest.for.stats.up, by = "gene.id")
intron.closest.up.data <- data_frame(chr = x1$chr.y,
                                     start = x1$start.y,
                                     end = x1$end.y,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.y,
                                     id = x1$ids.x,
                                     type = x1$type.y,
                                     length = x1$length.y,
                                     sameStrand = x1$sameStrand.y,
                                     tRNAFirst = x1$tRNAFirst.y,
                                     tRNA.upstream = x1$tRNA.upstream.y)

x1 <- merge(tRNA.down.intergenic, intron.closest.for.stats.down, by = "gene.id")
intron.closest.down.data <- data_frame(chr = x1$chr.y,
                                       start = x1$start.y,
                                       end = x1$end.y,
                                       ids = x1$ids.y,
                                       gene.id = x1$gene.id,
                                       strand = x1$gene.strand.y,
                                       id = x1$ids.x,
                                       type = x1$type.y,
                                       length = x1$length.y,
                                       sameStrand = x1$sameStrand.y,
                                       tRNAFirst = x1$tRNAFirst.y,
                                       tRNA.upstream = x1$tRNA.upstream.y)


x1 <- merge(tRNA.up.intergenic, intron.2nd_closest.for.stats.up, by = "gene.id")
intron.2nd.closest.up.data <- data_frame(chr = x1$chr.y,
                                         start = x1$start.y,
                                         end = x1$end.y,
                                         ids = x1$ids.y,
                                         gene.id = x1$gene.id,
                                         strand = x1$gene.strand.y,
                                         id = x1$ids.x,
                                         type = x1$type.y,
                                         length = x1$length.y,
                                         sameStrand = x1$sameStrand.y,
                                         tRNAFirst = x1$tRNAFirst.y,
                                         tRNA.upstream = x1$tRNA.upstream.y)

x1 <- merge(tRNA.down.intergenic, intron.2nd_closest.for.stats.down, by = "gene.id")
intron.2nd.closest.down.data <- data_frame(chr = x1$chr.y,
                                           start = x1$start.y,
                                           end = x1$end.y,
                                           ids = x1$ids.y,
                                           gene.id = x1$gene.id,
                                           strand = x1$gene.strand.y,
                                           id = x1$ids.x,
                                           type = x1$type.y,
                                           length = x1$length.y,
                                           sameStrand = x1$sameStrand.y,
                                           tRNAFirst = x1$tRNAFirst.y,
                                           tRNA.upstream = x1$tRNA.upstream.y)


# form porper intergenic data
intergenic.data <- intergenic.info %>%
  dplyr::select(chr, start, end, ids, gene.id, strand, type, length, sameStrand, tRNAFirst, tRNA.upstream) %>%
  add_column(id = id, .after = "strand")

# put everything togeher
final.stats.parid <- do.call("rbind", list(intron.closest.up.data,
                                           intron.closest.down.data,
                                           intron.2nd.closest.up.data,
                                           intron.2nd.closest.down.data,
                                           intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
final.stats.test <- final.stats.parid %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length)

aveCoverage.all <- AC.final %>%
  left_join(final.stats.test, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final <- aveCoverage.all %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_tibble() %>%
  arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene <- aveCoverage.final %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 2 elements with different comparison and do the t.test
tTestResults.final <- tRnaToGene$ids %>% 
  # extract(1) %>%
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene, ids ==x)$id
    cov <- filter(aveCoverage.final, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )
    
    # Compare the introns
    if (all(c("intron_2nd_closest_to_intergenic", "intron_closest_to_intergenic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_closest_to_intergenic"]+1),
                      log(cov[,"intron_2nd_closest_to_intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intron_2nd_closest_to_intergenicVsintron_closest_to_intergenic",
                     df = tTest$parameter, # degree of freedom
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    
    # Compare the intergenic regions
    if (all(c("intergenic", "intron_closest_to_intergenic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_closest_to_intergenic"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "IntergenicVsintron_closest_to_intergenic",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## t.test output
```{r two way filtering}
# for FDR
intergeic.sign.final <- tTestResults.final$IntergenicVsintron_closest_to_intergenic %>% 
  filter(FDR < 0.05, V < 0) 
intron.not.sign.final <- tTestResults.final$intron_2nd_closest_to_intergenicVsintron_closest_to_intergenic %>% 
  filter((FDR < 0.05 & V > 0) | FDR >=0.05)
final.sign <- intersect(intron.not.sign.final$id,intergeic.sign.final$id)
#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
#intron.not.sign.final <- tTestResults.final$Intron2VsIntron1 %>% 
 # filter((adjP < 0.05 & V > 0) | adjP >=0.05) 
#final.sign.adjP <- intersect(intron.not.sign.final$id,intergeic.sign.final$id) 
```
## assess continuous coverage for candidates that pass the t.test
```{r}
allIntergenic <- names(coverage.intergenic$EE1.sorted.merged.bam) # pull out sample name from any sample
allSamples <- names(coverage.intergenic)
coverage.samples <- lapply(allIntergenic,function(intergenic){
  v <- lapply(allSamples, function(sample){
    coverage.intergenic[[sample]][[intergenic]] %>% as.integer()
  }) 
  v <- do.call(rbind,v)
  rownames(v) <- allSamples
  return(t(v))
})
names(coverage.samples) <- allIntergenic

coverage.list.final <- nZero.intergenic %>%
  merge(final.stats.parid, by = "ids") %>% 
 filter(id %in% final.sign) %>%
  mutate(continu.cov = rowSums(dplyr::select(., contains("nZero"))) == 0)

# make all coverage data addable for each sample and assess the continious Cov for combined coverage
keptIntergenic <- coverage.list.final$ids
coverage.samples.final <- coverage.samples[names(coverage.samples) %in% keptIntergenic] 
combined.nZero <- coverage.samples.final %>% 
  lapply(function(intergenic){
    sum(rowSums(intergenic)==0)
  }) %>% unlist() %>% as.data.frame() %>% rownames_to_column() %>%
  set_colnames(c("ids","Combined.nZero"))

continuous.coverage.final <- left_join(coverage.list.final,combined.nZero, by = "ids") %>%
  mutate(Combined.nZero = Combined.nZero == 0) %>%
  setnames("Combined.nZero", "combined.continu.cov")
```
# export results
```{r}
##output the file
write.table(continuous.coverage.final,
            file = "C:/AAAStudy/PhD/Bioinformatics/Pastor/result/EE_Berry_with_two_intron.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
```
#Do t-test for candidates with one or no intron
####Candidates with one intron: In this version of pipeline, I will do t-test only one time, by using intron 1 compare with intergenic region. Then, I will use the flanking region outside of tRNA with same length as intergenic region as intron2 to do two time t-test. In the end I will use the overlaping candidates as the final candidates pass t-test.
```{r}
#step1. use intron.1 do a single time t-test with intron.1 vs intergenic region
# keep combination id safe
id <- input.data$id
# get correct intron information for candidates with one intron
One.intron.info <- intron.info %>% filter(gene.id %in% tgene.expressed.with2exon$gene.id)
# corrdinates for closest intron to intergenic for tRNA.up.intergeic 
list.gene.id <- unique(tRNA.up.intergenic$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(One.intron.info$gene.id == g)
  start <- One.intron.info$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)

intron.one.for.stats.up <- One.intron.info[res,]
intron.one.for.stats.up <- data_frame(chr = intron.one.for.stats.up$chr,
                                          start = intron.one.for.stats.up$intron.start,
                                          end = intron.one.for.stats.up$intron.end,
                                          strand = intron.one.for.stats.up$gene.strand,
                                          ids = intron.one.for.stats.up$intron.id,
                                          gene.id = intron.one.for.stats.up$gene.id,
                                          type = rep("intron_for_one_intron", nrow(intron.one.for.stats.up)),
                                          gene.strand = intron.one.for.stats.up$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(intron.one.for.stats.up)),
                                          tRNAFirst = rep("NA", nrow(intron.one.for.stats.up)),
                                          tRNA.upstream = rep("NA", nrow(intron.one.for.stats.up)))

# range for closest intron to intergenic for tRNA.down.intergeic 
list.gene.id <- unique(tRNA.down.intergenic$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(One.intron.info$gene.id == g)
  start <- One.intron.info$intron.start[rowNb]
  or <- order(start)
  rowNb[or==max(or)]
}) 
res <- unlist(res)

intron.one.for.stats.down <- One.intron.info[res,]
intron.one.for.stats.down <- data_frame(chr = intron.one.for.stats.down$chr,
                                            start = intron.one.for.stats.down$intron.start,
                                            end = intron.one.for.stats.down$intron.end,
                                            strand = intron.one.for.stats.down$gene.strand,
                                            ids = intron.one.for.stats.down$intron.id,
                                            gene.id = intron.one.for.stats.down$gene.id,
                                            type = rep("intron_for_one_intron", nrow(intron.one.for.stats.down)),
                                            gene.strand = intron.one.for.stats.down$gene.strand,
                                            length = end-start+1,
                                            sameStrand = rep("NA", nrow(intron.one.for.stats.down)),
                                            tRNAFirst = rep("NA", nrow(intron.one.for.stats.down)),
                                            tRNA.upstream = rep("NA", nrow(intron.one.for.stats.down)))


# combine info together for intron one in candidates with one intron
intron.one <- do.call("rbind", list(intron.one.for.stats.up,
                                        intron.one.for.stats.down)) %>% 
  arrange(gene.id) %>% 
  unique()
# put together for calculate average coverage (AC): intron one, intergenic
One.intron.stats.info <- do.call("rbind", list(intron.one,
                                          intergenic.info)) %>%
  arrange(gene.id)
```
### write intron one info into ``GRange`` object
```{r}
# intron closest
GRange_intron.one <- intron.one %>%
  dplyr::select(chr, start, end, ids, type) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "ids", "type")) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                           ignore.strand = TRUE,
                           seqinfo = Seqinfo,
                           seqnames.field = "chr",
                           start.field = "intron.start",
                           end.field = "intron.end",
                           strand.field = NULL,
                           starts.in.df.are.0based = FALSE) 
```
## use ``Cal_Coverage()`` to look through ``bam`` files for coverage of intron one
```{r, coverage of intron one}
# calculate the AC and nZero for each sample
coverage.intron.one <- lapply (bamfiles,function(bamfile){
  Cal_Coverage(GRange_intron.one, bamfile)
}) 

names(coverage.intron.one) <- SampleName
IntronName <- names(coverage.intron.one$EE1.sorted.merged.bam) # same as DicistronicName

# form a proper dataframe for all intron closest AC
AC.intron.one <- lapply(names(coverage.intron.one), function(x){
  coverage.intron.one[[x]] %>%
    lapply(function(i){
      data.frame(AveCov = mean(i))}) %>% 
    dplyr::bind_rows() %>%
    set_colnames(paste0(x,"_AveCov"))
}) %>%
  dplyr::bind_cols() %>%
  dplyr::mutate(ids = IntronName) %>%
  dplyr::select(ids, everything())

# gethering Average Coverage data for t-test
AC.intergenic.intron.one <- do.call("rbind", list(AC.intergenic,
                                  AC.intron.one))
```
## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(tRNA.up.intergenic, intron.one.for.stats.up, by = "gene.id")
intron.one.up.data <- data_frame(chr = x1$chr.y,
                                     start = x1$start.y,
                                     end = x1$end.y,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.y,
                                     id = x1$ids.x,
                                     type = x1$type.y,
                                     length = x1$length.y,
                                     sameStrand = x1$sameStrand.y,
                                     tRNAFirst = x1$tRNAFirst.y,
                                     tRNA.upstream = x1$tRNA.upstream.y)

x1 <- merge(tRNA.down.intergenic, intron.one.for.stats.down, by = "gene.id")
intron.one.down.data <- data_frame(chr = x1$chr.y,
                                       start = x1$start.y,
                                       end = x1$end.y,
                                       ids = x1$ids.y,
                                       gene.id = x1$gene.id,
                                       strand = x1$gene.strand.y,
                                       id = x1$ids.x,
                                       type = x1$type.y,
                                       length = x1$length.y,
                                       sameStrand = x1$sameStrand.y,
                                       tRNAFirst = x1$tRNAFirst.y,
                                       tRNA.upstream = x1$tRNA.upstream.y)
# put everything togeher
One.intron.stats.parid <- do.call("rbind", list(intron.one.up.data,
                                           intron.one.down.data,
                                           intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
One.intron.stats.test <- One.intron.stats.parid %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length)

aveCoverage.One.intron <- AC.intergenic.intron.one %>%
  left_join(One.intron.stats.test, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final.one.intron <- aveCoverage.One.intron %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_tibble() %>%
  arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene.one.intron <- aveCoverage.final.one.intron %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 1 elements with comparison of intron one to intergenic and do the t.test
tTestResults.one.intron <- tRnaToGene.one.intron$ids %>% 
  # extract(1) %>%
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene.one.intron, ids ==x)$id
    cov <- filter(aveCoverage.final.one.intron, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )

    # Compare the intergenic regions
    if (all(c("intergenic", "intron_for_one_intron") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_for_one_intron"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "IntergenicVsintron_for_one_intron",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## one step t.test output
```{r two way filtering}
# for FDR
intergeic.sign.final.one.intron <- tTestResults.one.intron$IntergenicVsintron_for_one_intron %>% 
  filter(FDR < 0.05, V < 0) 
final.sign.with.one.intron <- intergeic.sign.final.one.intron$id
#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
```
######Using flanking region mimic intron 2 to do t-test for candidates with only one intron
```{r}
# Get the flanking region from tRNA side which has same length as intergenic region and use it as intron.mimic.
One.intron.with.tRNA.info <- left_join(One.intron.info, tRNA.CDS.expressed.combo, by = 'gene.id') %>%
  dplyr::select(chr.x, tRNA.start, tRNA.end, tRNA.strand, id, gene.id, gene.strand.x, interval.length, gene.start, gene.end, tRNAFirst, tRNA.upstream) %>%
  set_colnames(c("chr.x", "tRNA.start", "tRNA.end", "tRNA.strand", "ids", "gene.id", "gene.strand.x", "interval.length", "gene.start", "gene.end", "tRNAFirst", "tRNA.upstream"))

# seperate tRNA first and gene first: If tRNA first, flanking region is before tRNA, end of intron mimic is 1 bp before start of tRNA. If gene first, flanking region is after tRNA, start of intron mimic is 1bp after end of tRNA.
tRNA.up.one.intron <- filter(One.intron.with.tRNA.info, 
                             tRNAFirst == TRUE)

tRNA.down.one.intron <- filter(One.intron.with.tRNA.info, 
                               tRNAFirst == FALSE)

#use same length from tRNA to mimic intron 1
One.intron.mimic.intron.up <- tRNA.up.one.intron %>% dplyr::select(chr.x, tRNA.start, tRNA.end, gene.id, gene.strand.x, interval.length, gene.start, gene.end) %>%
  mutate(tRNA.start = tRNA.start-1 ) #this is the end of mimic intron:one position before tRNA start

One.intron.mimic.intron.start <- c(tRNA.up.one.intron$tRNA.start-tRNA.up.one.intron$interval.length) #mimic intron start

One.intron.mimic.intron.ids <- c(".one.intron.mimic") #mimic intron id

One.intron.mimic.intron.up$One.intron.mimic.intron.start <- One.intron.mimic.intron.start 

One.intron.mimic.intron.up$One.intron.mimic.intron.ids <- One.intron.mimic.intron.ids 

One.intron.mimic.intron.up <- One.intron.mimic.intron.up %>% dplyr::select(chr.x, One.intron.mimic.intron.start, tRNA.start, gene.strand.x, One.intron.mimic.intron.ids, gene.id, interval.length) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "strand", "ids", "gene.id", "length"))  %>%
  mutate(ids=paste0(One.intron.mimic.intron.up$gene.id,ids))

list.gene.id <- unique(tRNA.up.one.intron$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(One.intron.mimic.intron.up$gene.id == g)
  start <- One.intron.mimic.intron.up$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)

One.intron.mimic.for.stats.up <- One.intron.mimic.intron.up
One.intron.mimic.for.stats.up <- data_frame(chr = One.intron.mimic.for.stats.up$chr,
                                          start = One.intron.mimic.for.stats.up$intron.start,
                                          end = One.intron.mimic.for.stats.up$intron.end,
                                          strand = One.intron.mimic.for.stats.up$strand,
                                          ids = One.intron.mimic.for.stats.up$ids,
                                          gene.id = One.intron.mimic.for.stats.up$gene.id,
                                          type = rep("One_intron_mimic", nrow(One.intron.mimic.for.stats.up)),
                                          gene.strand = One.intron.mimic.for.stats.up$strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(One.intron.mimic.for.stats.up)),
                                          tRNAFirst = rep("NA", nrow(One.intron.mimic.for.stats.up)),
                                          tRNA.upstream = rep("NA", nrow(One.intron.mimic.for.stats.up)))


One.intron.mimic.intron.down <- tRNA.down.one.intron %>% dplyr::select(chr.x, tRNA.start, tRNA.end, gene.id, gene.strand.x, interval.length, gene.start, gene.end) %>%
  mutate(tRNA.end = tRNA.end+1 ) #this is the start of mimic intron when tRNA first=false: one position after tRNA end

One.intron.down.mimic.intron.end <- c(tRNA.down.one.intron$tRNA.end+tRNA.down.one.intron$interval.length) #mimic intron end

One.intron.down.mimic.intron.ids <- c(".one.intron.mimic") #mimic intron id

One.intron.mimic.intron.down$One.intron.down.mimic.intron.end <- One.intron.down.mimic.intron.end 

One.intron.mimic.intron.down$One.intron.down.mimic.intron.ids <- One.intron.down.mimic.intron.ids 

One.intron.mimic.intron.down <- One.intron.mimic.intron.down %>% dplyr::select(chr.x, tRNA.end, One.intron.down.mimic.intron.end, gene.strand.x, One.intron.down.mimic.intron.ids, gene.id, interval.length) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "strand", "ids", "gene.id", "length"))  %>%
  mutate(ids=paste0(One.intron.mimic.intron.down$gene.id,ids))

list.gene.id <- unique(tRNA.down.one.intron$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(One.intron.mimic.intron.down$gene.id == g)
  start <- One.intron.mimic.intron.down$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)

One.intron.mimic.for.stats.down <- One.intron.mimic.intron.down
One.intron.mimic.for.stats.down <- data_frame(chr = One.intron.mimic.for.stats.down$chr,
                                          start = One.intron.mimic.for.stats.down$intron.start,
                                          end = One.intron.mimic.for.stats.down$intron.end,
                                          strand = One.intron.mimic.for.stats.down$strand,
                                          ids = One.intron.mimic.for.stats.down$ids,
                                          gene.id = One.intron.mimic.for.stats.down$gene.id,
                                          type = rep("One_intron_mimic", nrow(One.intron.mimic.for.stats.down)),
                                          gene.strand = One.intron.mimic.for.stats.down$strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(One.intron.mimic.for.stats.down)),
                                          tRNAFirst = rep("NA", nrow(One.intron.mimic.for.stats.down)),
                                          tRNA.upstream = rep("NA", nrow(One.intron.mimic.for.stats.down)))

#bind up and down to get intron mimic
One.intron.mimic <- do.call("rbind", list(One.intron.mimic.for.stats.up,
                                        One.intron.mimic.for.stats.down)) %>% 
  arrange(gene.id) %>% 
  unique() %>% group_by(gene.id) %>% slice_min(n = 1, length)%>%
    ungroup() #"group_by(gene.id) %>% slice_min(n = 1, length)%>% ungroup()" this part is because for same gene id, we can get more than one tRNA combinations. I select the most closest tRNA as the gene.tRNA combination.
```
#build GRange for intron mimic
```{r}
# intron mimic
GRange_One.intron.mimic <- One.intron.mimic %>%
  dplyr::select(chr, start, end, ids, type)%>%
  set_colnames(c("chr", "intron.start", "intron.end", "ids", "type")) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                           ignore.strand = TRUE,
                           seqinfo = Seqinfo,
                           seqnames.field = "chr",
                           start.field = "intron.start",
                           end.field = "intron.end",
                           strand.field = NULL,
                           starts.in.df.are.0based = FALSE)
```
## use ``Cal_Coverage()`` to look through ``bam`` files for coverage of each base
```{r, coverage of intron mimic}
# calculate the AC and nZero for each sample
coverage.One.intron.mimic <- lapply (bamfiles,function(bamfile){
  Cal_Coverage(GRange_One.intron.mimic, bamfile)
})

names(coverage.One.intron.mimic) <- SampleName
IntronName <- names(coverage.One.intron.mimic$EE1.sorted.merged.bam) # same as DicistronicName

# form a proper dataframe for all intron closest AC
AC.One.intron.mimic <- lapply(names(coverage.One.intron.mimic), function(x){
  coverage.One.intron.mimic[[x]] %>%
    lapply(function(i){
      data.frame(AveCov = mean(i))}) %>% 
    dplyr::bind_rows() %>%
    set_colnames(paste0(x,"_AveCov"))
}) %>%
  dplyr::bind_cols() %>%
  dplyr::mutate(ids = IntronName) %>%
  dplyr::select(ids, everything())
```

```{r}
# gethering Average Coverage data for t-test
AC.final.one.intron.with.mimic<- do.call("rbind", list(AC.intergenic,
                                  AC.intron.one,
                                  AC.One.intron.mimic))
```
## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(tRNA.up.one.intron, intron.one.for.stats.up, by = "gene.id")
intron.one.up.data <- data_frame(chr = x1$chr,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.x,
                                     id = x1$ids.x,
                                     type = x1$type,
                                     length = x1$length,
                                     sameStrand = x1$sameStrand,
                                     tRNAFirst = x1$tRNAFirst.x,
                                     tRNA.upstream = x1$tRNA.upstream.x)

x1 <- merge(tRNA.down.one.intron, intron.one.for.stats.down, by = "gene.id")
intron.one.down.data <- data_frame(chr = x1$chr,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.x,
                                     id = x1$ids.x,
                                     type = x1$type,
                                     length = x1$length,
                                     sameStrand = x1$sameStrand,
                                     tRNAFirst = x1$tRNAFirst.x,
                                     tRNA.upstream = x1$tRNA.upstream.x)


x1 <- merge(tRNA.up.one.intron, One.intron.mimic.for.stats.up, by = "gene.id")
intron.One.mimic.up.data <- data_frame(chr = x1$chr,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.x,
                                     id = x1$ids.x,
                                     type = x1$type,
                                     length = x1$length,
                                     sameStrand = x1$sameStrand,
                                     tRNAFirst = x1$tRNAFirst.x,
                                     tRNA.upstream = x1$tRNA.upstream.x)

x1 <- merge(tRNA.down.one.intron, One.intron.mimic.for.stats.down, by = "gene.id")
intron.One.mimic.down.data <- data_frame(chr = x1$chr,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids.y,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.x,
                                     id = x1$ids.x,
                                     type = x1$type,
                                     length = x1$length,
                                     sameStrand = x1$sameStrand,
                                     tRNAFirst = x1$tRNAFirst.x,
                                     tRNA.upstream = x1$tRNA.upstream.x)

# put everything togeher
final.stats.parid.One.intron.mimic <- do.call("rbind", list(intron.one.up.data,
                                           intron.one.down.data,
                                           intron.One.mimic.up.data,
                                           intron.One.mimic.down.data,
                                           intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
final.stats.test.intron.one.mimic <- final.stats.parid.One.intron.mimic %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length)

aveCoverage.all.one.intron.mimic <- AC.final.one.intron.with.mimic %>%
  left_join(final.stats.test.intron.one.mimic, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final.one.intron.mimic <- aveCoverage.all.one.intron.mimic %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_data_frame() %>%group_by(ids) %>% slice_min(n = 1, start)%>%
    ungroup()%>% arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene.one.intron.mimic <- aveCoverage.final.one.intron.mimic %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 2 elements with different comparison and do the t.test
tTestResults.final.for.one.intron.mimic <- tRnaToGene.one.intron.mimic$ids %>% 
  # extract(1) %>%
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene.one.intron.mimic, ids ==x)$id
    cov <- filter(aveCoverage.final.one.intron.mimic, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )
    
    # Compare the introns
    if (all(c("intron_for_one_intron", "One_intron_mimic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_for_one_intron"]+1),
                      log(cov[,"One_intron_mimic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "One_intron_mimicVsintron_for_one_intron",
                     df = tTest$parameter, # degree of freedom
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    
    # Compare the intergenic regions
    if (all(c("intergenic", "intron_for_one_intron") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_for_one_intron"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intergenicVsintron_for_one_intron",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## t.test output
```{r two way filtering}
# for FDR
intergeic.sign.final.intron.one.mimic <- tTestResults.final.for.one.intron.mimic$intergenicVsintron_for_one_intron %>% 
  filter(FDR < 0.05, V < 0) 
intron.not.sign.final.mimic <- tTestResults.final.for.one.intron.mimic$One_intron_mimicVsintron_for_one_intron %>% 
  filter((FDR < 0.05 & V > 0) | FDR >=0.05)
final.sign.with.mimic.intron <- intersect(intron.not.sign.final.mimic$id,intergeic.sign.final.intron.one.mimic$id)
#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
#intron.not.sign.final <- tTestResults.final$Intron2VsIntron1 %>% 
 # filter((adjP < 0.05 & V > 0) | adjP >=0.05) 
#final.sign.adjP <- intersect(intron.not.sign.final$id,intergeic.sign.final$id) 
```
###filter ids that overlapped with two methods
```{r}
final.sign.overlap <- intersect(final.sign.with.one.intron,final.sign.with.mimic.intron)
```
## assess continuous coverage for candidates that pass the t.test
```{r}
#filter no zero coverage in intergenic region and pass t-test with both methods
coverage.list.final.intron.one <- nZero.intergenic %>%
  merge(final.stats.parid.One.intron.mimic, by = "ids") %>%
 filter(id %in% final.sign.overlap) %>%
  mutate(continu.cov = rowSums(dplyr::select(., contains("nZero"))) == 0)

# make all coverage data addable for each sample and assess the continious Cov for combined coverage
keptIntergenic.intron.one <- coverage.list.final.intron.one$ids
coverage.samples.final.intron.one <- coverage.samples[names(coverage.samples) %in% keptIntergenic.intron.one] 
combined.nZero.intron.one <- coverage.samples.final.intron.one %>% 
  lapply(function(intergenic){
    sum(rowSums(intergenic)==0)
  }) %>% unlist() %>% as.data.frame() %>% rownames_to_column() %>%
  set_colnames(c("ids","Combined.nZero"))

continuous.coverage.final.one.intron <- left_join(coverage.list.final.intron.one,combined.nZero.intron.one, by = "ids") %>%
  mutate(Combined.nZero = Combined.nZero == 0) %>%
  setnames("Combined.nZero", "combined.continu.cov")
```
# export results
```{r}
write.table(continuous.coverage.final.one.intron,
            file = "C:/AAAStudy/PhD/Bioinformatics/Pastor/result/EE_Berry_with_one_intron.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
```
######I want to do a t-test for positive result with no intron. I can use the flanking region outside of tRNA with same length as intergenic region as intron2
```{r}
#1. get tgene.expressed without intron
# get tgene.expressed with one exon, one exon means no intron 
tgene.expressed.no.intron <- left_join(tgene.only.one.exon,tRNA.CDS.combo,by = "gene.id") %>%
#    mutate(ids = sub(".*intergenic_", "",ids))
#names(positive.with1intron)[names(positive.with1intron) == 'ids'] <- 'id'%>%
  dplyr::select(chr.x, gene.start, gene.end, gene.id, gene.strand.x) %>%
    set_colnames(c("gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand"))%>%
    arrange(gene.chr, gene.start)%>%
  unique()
write.table(tgene.expressed.no.intron,
            file = "C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/tgene_expressed_no_intron.txt",
            quote = FALSE, sep = "\t",
            row.names = FALSE, col.names = FALSE)

# get correct intron information for candidates without intron
no.intron.info <- left_join(tgene.expressed.no.intron,tRNA.CDS.expressed.combo, by = "gene.id") %>%
  unique()%>%
  dplyr::select(chr,id, interval.length, tRNAFirst, tRNA.upstream, gene.id, gene.strand.x, tRNA.start, tRNA.end, tRNA.id, tRNA.strand, gene.start.x, gene.end.x) %>%
    set_colnames(c("chr", "id","length", "tRNAFirst", "tRNA.upstream", "gene.id", "gene.strand", "tRNA.start", "tRNA.end", "tRNA.id", "tRNA.strand", "gene.start", "gene.end")) 
sameStrand = no.intron.info$tRNA.strand == no.intron.info$gene.strand
no.intron.info <-  cbind(no.intron.info,sameStrand)

###--------------------------------------###

#2. get the region which has same length as intergenic region and use it as mimic introns 
# seperate tRNA first and gene first
tRNA.up.no.intron <- filter(no.intron.info, 
                             tRNAFirst == TRUE)

tRNA.down.no.intron <- filter(no.intron.info, 
                               tRNAFirst == FALSE)
###MIMIC INTRON 1
#For tRNA first (up), use same length from tRNA to mimic intron 1 
no.intron.mimic.intron1.up <- tRNA.up.no.intron %>% dplyr::select(chr, tRNA.start, tRNA.end, gene.id, gene.strand, length, gene.start, gene.end) %>%
  mutate(tRNA.start = tRNA.start-1 ) #this is the end of mimic intron 1 for tRNA up
no.intron.mimic.intron1.ids <- c("intron.1") # give mimic intron an id
no.intron.mimic.intron1.start <- c(no.intron.mimic.intron1.up$tRNA.start+1-no.intron.mimic.intron1.up$length) #this is the start of mimic intron1 for tRNA up
no.intron.mimic.intron1.up$no.intron.mimic.intron1.start <- no.intron.mimic.intron1.start 
no.intron.mimic.intron1.up$no.intron.mimic.intron1.ids <- paste(no.intron.mimic.intron1.up$gene.id, no.intron.mimic.intron1.ids, sep = ".") #combine gene id with intron id
no.intron.mimic.intron1.up <- no.intron.mimic.intron1.up %>% dplyr::select(chr, no.intron.mimic.intron1.start, tRNA.start, gene.strand, no.intron.mimic.intron1.ids, gene.id, length) %>%
  set_colnames(c("chr", "intron.start", "intron.end","gene.strand","ids", "gene.id", "length")) #put together as a dataframe

#For tRNA not first (down), use same length from tRNA to mimic intron 1
no.intron.mimic.intron1.down <- tRNA.down.no.intron %>% dplyr::select(chr, tRNA.start, tRNA.end, gene.id, gene.strand, length, gene.start, gene.end) %>%
  mutate(tRNA.end = tRNA.end+1 ) #this is the start of mimic intron 1 for tRNA down
no.intron.mimic.intron1.ids <- c("intron.1") # give mimic intron an id
no.intron.mimic.intron1.end <- c(no.intron.mimic.intron1.down$tRNA.end+no.intron.mimic.intron1.down$length) #this is the start of mimic intron1 for tRNA up
no.intron.mimic.intron1.down$no.intron.mimic.intron1.end <- no.intron.mimic.intron1.end 
no.intron.mimic.intron1.down$no.intron.mimic.intron1.ids <- paste(no.intron.mimic.intron1.down$gene.id, no.intron.mimic.intron1.ids, sep = ".") #combine gene id with intron id
no.intron.mimic.intron1.down <- no.intron.mimic.intron1.down %>% dplyr::select(chr, tRNA.end, no.intron.mimic.intron1.end, gene.strand, no.intron.mimic.intron1.ids, gene.id, length) %>%
  set_colnames(c("chr", "intron.start", "intron.end","gene.strand","ids", "gene.id", "length"))  #put together as a dataframe

###MIMIC INTRON 2
#For tRNA first (up), use same length from gene to mimic intron 2
no.intron.mimic.intron2.up <- tRNA.up.no.intron %>% dplyr::select(chr, tRNA.start, tRNA.start, gene.id, gene.strand, length, gene.start, gene.end) %>%
  mutate(gene.start = gene.end+1 ) #this is the start of the mimic intron2 for tRNA up
no.intron.mimic.intron2.end <- c(no.intron.mimic.intron2.up$gene.end+no.intron.mimic.intron2.up$length) #this is the end of the mimic intron2 for tRNA up. I use gene.end but not gene.end +1 is because gene end +1 is the first bp of interval.
no.intron.mimic.intron2.ids <- c("intron.2")
no.intron.mimic.intron2.up$no.intron.mimic.intron2.end <- no.intron.mimic.intron2.end 
no.intron.mimic.intron2.up$no.intron.mimic.intron2.ids <- paste(no.intron.mimic.intron2.up$gene.id, no.intron.mimic.intron2.ids, sep = ".") 
no.intron.mimic.intron2.up <- no.intron.mimic.intron2.up %>% dplyr::select(chr, gene.start, no.intron.mimic.intron2.end, gene.strand, no.intron.mimic.intron2.ids, gene.id, length) %>%
  set_colnames(c("chr", "intron.start", "intron.end","gene.strand","ids", "gene.id", "length"))

#For tRNA not first (down), use same length from gene to mimic intron 2
no.intron.mimic.intron2.down <- tRNA.down.no.intron %>% dplyr::select(chr, tRNA.start, tRNA.start, gene.id, gene.strand, length, gene.start, gene.end) %>%
  mutate(gene.start = gene.start-1 ) #this is the end of mimic intron 2 for tRNA up
no.intron.mimic.intron2.ids <- c("intron.2")
no.intron.mimic.intron2.start <- c(tRNA.down.no.intron$gene.start-tRNA.down.no.intron$length) #this is the start of the mimic intron2 for tRNA up. 
no.intron.mimic.intron2.down$no.intron.mimic.intron2.ids <- paste(no.intron.mimic.intron2.down$gene.id, no.intron.mimic.intron2.ids, sep = ".") 
no.intron.mimic.intron2.down$no.intron.mimic.intron2.start <- no.intron.mimic.intron2.start  
no.intron.mimic.intron2.down <- no.intron.mimic.intron2.down %>% dplyr::select(chr, no.intron.mimic.intron2.start,gene.start, gene.strand, no.intron.mimic.intron2.ids, gene.id, length) %>%
  set_colnames(c("chr", "intron.start", "intron.end","gene.strand","ids", "gene.id", "length")) 

#give numbers to mimic introns, and use the number of gene make intron statistic dataframe
#intron 1 up
list.gene.id <- unique(tRNA.up.no.intron$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(no.intron.mimic.intron1.up$gene.id == g)
  start <- no.intron.mimic.intron1.up$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)
#make statistic dataframe for intron 1 up
intron1.mimic.for.stats.up <- no.intron.mimic.intron1.up
intron1.mimic.for.stats.up <- data_frame(chr = intron1.mimic.for.stats.up$chr,
                                          start = intron1.mimic.for.stats.up$intron.start,
                                          end = intron1.mimic.for.stats.up$intron.end,
                                          strand = intron1.mimic.for.stats.up$gene.strand,
                                          ids = intron1.mimic.for.stats.up$ids,
                                          gene.id = intron1.mimic.for.stats.up$gene.id,
                                          type = rep("intron1_mimic", nrow(intron1.mimic.for.stats.up)),
                                          gene.strand = intron1.mimic.for.stats.up$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(intron1.mimic.for.stats.up)),
                                          tRNAFirst = rep("NA", nrow(intron1.mimic.for.stats.up)),
                                          tRNA.upstream = rep("NA", nrow(intron1.mimic.for.stats.up)))
#intron 1 down
list.gene.id <- unique(tRNA.down.no.intron$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(no.intron.mimic.intron1.down$gene.id == g)
  start <- no.intron.mimic.intron1.down$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)
#make statistic dataframe for intron 1 down
intron1.mimic.for.stats.down <- no.intron.mimic.intron1.down
intron1.mimic.for.stats.down <- data_frame(chr = intron1.mimic.for.stats.down$chr,
                                          start = intron1.mimic.for.stats.down$intron.start,
                                          end = intron1.mimic.for.stats.down$intron.end,
                                          strand = intron1.mimic.for.stats.down$gene.strand,
                                          ids = intron1.mimic.for.stats.down$ids,
                                          gene.id = intron1.mimic.for.stats.down$gene.id,
                                          type = rep("intron1_mimic", nrow(intron1.mimic.for.stats.down)),
                                          gene.strand = intron1.mimic.for.stats.down$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(intron1.mimic.for.stats.down)),
                                          tRNAFirst = rep("NA", nrow(intron1.mimic.for.stats.down)),
                                          tRNA.upstream = rep("NA", nrow(intron1.mimic.for.stats.down)))

#intron 2 up
list.gene.id <- unique(tRNA.up.no.intron$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(no.intron.mimic.intron2.up$gene.id == g)
  start <- no.intron.mimic.intron2.up$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)
#make statistic dataframe for intron 2 up
intron2.mimic.for.stats.up <- no.intron.mimic.intron2.up
intron2.mimic.for.stats.up <- data_frame(chr = intron2.mimic.for.stats.up$chr,
                                            start = intron2.mimic.for.stats.up$intron.start,
                                            end = intron2.mimic.for.stats.up$intron.end,
                                            strand = intron2.mimic.for.stats.up$gene.strand,
                                            ids = intron2.mimic.for.stats.up$ids,
                                            gene.id = intron2.mimic.for.stats.up$gene.id,
                                            type = rep("intron2_mimic", nrow(intron2.mimic.for.stats.up)),
                                            gene.strand = intron2.mimic.for.stats.up$gene.strand,
                                            length = end-start+1,
                                            sameStrand = rep("NA", nrow(intron2.mimic.for.stats.up)),
                                            tRNAFirst = rep("NA", nrow(intron2.mimic.for.stats.up)),
                                            tRNA.upstream = rep("NA", nrow(intron2.mimic.for.stats.up)))

#intron 2 down
list.gene.id <- unique(tRNA.down.no.intron$gene.id)
res <- sapply(list.gene.id,function(g){
  rowNb <- which(no.intron.mimic.intron2.down$gene.id == g)
  start <- no.intron.mimic.intron2.down$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)
#make statistic dataframe for intron 2 down
intron2.mimic.for.stats.down <- no.intron.mimic.intron2.down
intron2.mimic.for.stats.down <- data_frame(chr = intron2.mimic.for.stats.down$chr,
                                            start = intron2.mimic.for.stats.down$intron.start,
                                            end = intron2.mimic.for.stats.down$intron.end,
                                            strand = intron2.mimic.for.stats.down$gene.strand,
                                            ids = intron2.mimic.for.stats.down$ids,
                                            gene.id = intron2.mimic.for.stats.down$gene.id,
                                            type = rep("intron2_mimic", nrow(intron2.mimic.for.stats.down)),
                                            gene.strand = intron2.mimic.for.stats.down$gene.strand,
                                            length = end-start+1,
                                            sameStrand = rep("NA", nrow(intron2.mimic.for.stats.down)),
                                            tRNAFirst = rep("NA", nrow(intron2.mimic.for.stats.down)),
                                            tRNA.upstream = rep("NA", nrow(intron2.mimic.for.stats.down)))

# combine info together for mimic intron1 and 2
no.intron.mimic.intron1 <- do.call("rbind", list(intron1.mimic.for.stats.down,
                                                 intron1.mimic.for.stats.up)) %>% 
  arrange(gene.id) %>% 
  unique()%>% group_by(gene.id) %>% slice_min(n = 1, length)%>%
    ungroup()

no.intron.mimic.intron2 <- do.call("rbind", list(intron2.mimic.for.stats.down,
                                                 intron2.mimic.for.stats.up)) %>% 
  arrange(gene.id) %>% 
  unique()%>% group_by(gene.id) %>% slice_min(n = 1, length)%>%
    ungroup()
intergenic.info.no.intron <- intergenic.info %>% group_by(gene.id) %>% slice_min(n = 1, length)%>%
    ungroup()
# put everything together for calculate average coverage (AC)
final.stats.info.no.intron <- do.call("rbind", list(no.intron.mimic.intron1,
                                          no.intron.mimic.intron2,
                                          intergenic.info.no.intron)) %>%
  arrange(gene.id)
```
#build GRange for intron and mimic intron
```{r}
# Mimic intron 1
GRange_no.intron.mimic.intron1 <- no.intron.mimic.intron1 %>%
  dplyr::select(chr, start, end, ids, type) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "ids", "type")) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                           ignore.strand = TRUE,
                           seqinfo = Seqinfo,
                           seqnames.field = "chr",
                           start.field = "intron.start",
                           end.field = "intron.end",
                           strand.field = NULL,
                           starts.in.df.are.0based = FALSE) 
# Mimic intron 2
GRange_no.intron.mimic.intron2 <- no.intron.mimic.intron2 %>%
  dplyr::select(chr, start, end, ids, type) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "ids", "type")) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                           ignore.strand = TRUE,
                           seqinfo = Seqinfo,
                           seqnames.field = "chr",
                           start.field = "intron.start",
                           end.field = "intron.end",
                           strand.field = NULL,
                           starts.in.df.are.0based = FALSE)
```
## use ``Cal_Coverage()`` to look through ``bam`` files for coverage of each base
```{r, coverage of mimic.intron1  }
# calculate the AC and nZero for each sample
coverage.no.intron.mimic.intron1 <- lapply (bamfiles,function(bamfile){
  Cal_Coverage(GRange_no.intron.mimic.intron1, bamfile)
})
names(coverage.no.intron.mimic.intron1) <- SampleName
IntronName <- names(coverage.no.intron.mimic.intron1$EE1.sorted.merged.bam) # same as DicistronicName

# form a proper dataframe for mimic intron 1 AC
AC.no.intron.mimic.intron1 <- lapply(names(coverage.no.intron.mimic.intron1), function(x){
  coverage.no.intron.mimic.intron1[[x]] %>%
    lapply(function(i){
      data.frame(AveCov = mean(i))}) %>% 
    dplyr::bind_rows() %>%
    set_colnames(paste0(x,"_AveCov"))
}) %>%
  dplyr::bind_cols() %>%
  dplyr::mutate(ids = IntronName) %>%
  dplyr::select(ids, everything())
```

```{r, coverage of mimic.intron2 }
# calculate the AC and nZero for each sample
coverage.no.intron.mimic.intron2 <- lapply (bamfiles,function(bamfile){
  Cal_Coverage(GRange_no.intron.mimic.intron2, bamfile)
})
names(coverage.no.intron.mimic.intron2) <- SampleName
IntronName <- names(coverage.no.intron.mimic.intron2$EE1.sorted.merged.bam) # same as DicistronicName

# form a proper dataframe for mimic intron 2 AC
AC.no.intron.mimic.intron2 <- lapply(names(coverage.no.intron.mimic.intron2), function(x){
  coverage.no.intron.mimic.intron2[[x]] %>%
    lapply(function(i){
      data.frame(AveCov = mean(i))}) %>% 
    dplyr::bind_rows() %>%
    set_colnames(paste0(x,"_AveCov"))
}) %>%
  dplyr::bind_cols() %>%
  dplyr::mutate(ids = IntronName) %>%
  dplyr::select(ids, everything())
```

```{r}
# gethering Average Coverage data for t-test
AC.mimic.final <- do.call("rbind", list(AC.intergenic,
                                  AC.no.intron.mimic.intron1,
                                  AC.no.intron.mimic.intron2))
```
## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(tRNA.up.no.intron, intron1.mimic.for.stats.up, by = "gene.id")
intron1.mimic.up.data <- data_frame(chr = x1$chr.y,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.y,
                                     id = x1$id,
                                     type = x1$type,
                                     length = x1$length.y,
                                     sameStrand = x1$sameStrand.y,
                                     tRNAFirst = x1$tRNAFirst.y,
                                     tRNA.upstream = x1$tRNA.upstream.y)
#tRNA downstream data frame has two rows with same gene id, and two rows with same length, so I will add a colonm on tRNA.down.no.intron with ids.
tRNA.down.no.intron$ids <- c(intron1.mimic.for.stats.down$ids) 
x1 <- merge(tRNA.down.no.intron, intron1.mimic.for.stats.down, by = "gene.id")
intron1.mimic.down.data <- data_frame(chr = x1$chr.y,
                                       start = x1$start,
                                       end = x1$end,
                                       ids = x1$ids.y,
                                       gene.id = x1$gene.id,
                                       strand = x1$gene.strand.y,
                                       id = x1$id,
                                       type = x1$type,
                                       length = x1$length.y,
                                       sameStrand = x1$sameStrand.y,
                                       tRNAFirst = x1$tRNAFirst.y,
                                       tRNA.upstream = x1$tRNA.upstream.y)

x1 <- merge(tRNA.up.no.intron, intron2.mimic.for.stats.up, by = "gene.id")
intron2.mimic.up.data <- data_frame(chr = x1$chr.y,
                                         start = x1$start,
                                         end = x1$end,
                                         ids = x1$ids,
                                         gene.id = x1$gene.id,
                                         strand = x1$gene.strand.y,
                                         id = x1$id,
                                         type = x1$type,
                                         length = x1$length.y,
                                         sameStrand = x1$sameStrand.y,
                                         tRNAFirst = x1$tRNAFirst.y,
                                         tRNA.upstream = x1$tRNA.upstream.y)

tRNA.down.no.intron$ids <- c(intron2.mimic.for.stats.down$ids) 
x1 <- merge(tRNA.down.no.intron, intron2.mimic.for.stats.down, by = "gene.id")
intron2.mimic.down.data <- data_frame(chr = x1$chr.y,
                                           start = x1$start,
                                           end = x1$end,
                                           ids = x1$ids.y,
                                           gene.id = x1$gene.id,
                                           strand = x1$gene.strand.y,
                                           id = x1$id,
                                           type = x1$type,
                                           length = x1$length.y,
                                           sameStrand = x1$sameStrand.y,
                                           tRNAFirst = x1$tRNAFirst.y,
                                           tRNA.upstream = x1$tRNA.upstream.y)


# form porper intergenic data
intergenic.data <- intergenic.info %>%
  dplyr::select(chr, start, end, ids, gene.id, strand, type, length, sameStrand, tRNAFirst, tRNA.upstream) %>%
  add_column(id = id, .after = "strand")

# put everything togeher
final.stats.parid.no.intron <- do.call("rbind", list(intron1.mimic.up.data,
                                           intron1.mimic.down.data,
                                           intron2.mimic.up.data,
                                           intron2.mimic.down.data,
                                           intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
final.stats.test.no.intron <- final.stats.parid.no.intron %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length) %>% group_by(ids) %>% slice_min(n = 1, length)%>%
    ungroup()

aveCoverage.all.no.intron <- AC.mimic.final %>%
  left_join(final.stats.test.no.intron, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final.no.intron <- aveCoverage.all.no.intron %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_data_frame() %>%  arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene.no.intron <- aveCoverage.final.no.intron %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 2 elements with different comparison and do the t.test
tTestResults.final.no.intron <- tRnaToGene.no.intron$ids %>% 
  # extract(1) %>% #extract 1 candidate and have a look
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene.no.intron, ids ==x)$id
    cov <- filter(aveCoverage.final.no.intron, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )
    
    # Compare the introns
    if (all(c("intron1_mimic", "intron2_mimic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron2_mimic"]+1),
                      log(cov[,"intron1_mimic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intron1_mimicVsintron2_mimic",
                     df = tTest$parameter, # degree of freedom
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    
    # Compare the intergenic regions
    if (all(c("intergenic", "intron1_mimic") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron1_mimic"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "IntergenicVsintron1_mimic",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## t.test output
```{r two way filtering}
# for FDR
intergeic.sign.final.no.intron <- tTestResults.final.no.intron$IntergenicVsintron1_mimic %>% 
  filter(FDR < 0.05, V < 0) 
intron.not.sign.final.no.intron <- tTestResults.final.no.intron$intron1_mimicVsintron2_mimic %>% 
  filter((FDR < 0.05 & V > 0) | FDR >=0.05)
final.sign.no.intron <- intersect(intron.not.sign.final.no.intron$id,intergeic.sign.final.no.intron$id)
#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
#intron.not.sign.final <- tTestResults.final$Intron2VsIntron1 %>% 
 # filter((adjP < 0.05 & V > 0) | adjP >=0.05) 
#final.sign.adjP <- intersect(intron.not.sign.final$id,intergeic.sign.final$id) 
```
###Now I will do t-test with another method: using introns from nearby gene which has two or more introns to mimic intron one and two 
## As we know introns are the only sure regions that do not have reads, so that is a better negative control of background reads and pre-mRNA reads. I will use the introns of nearby gene as control 
```{r}
# To get nearby gene, I need to get gene without intron and use samtool closed to get nearby gene information
#get gene information with 2 and more intron
exon.info.all.genes <- getBM(attributes=c("chromosome_name", "exon_chrom_start", "exon_chrom_end", 
                                "ensembl_exon_id","ensembl_gene_id", "strand"), mart=m) %>%
  set_colnames(c("chr","start","end","exon_UTR_id","gene.id","gene.strand")) %>%
  mutate(#chr = paste0('chr', chr),
         gene.strand = ifelse(gene.strand == 1,"+","-"))

exon.info.all.genes %<>% separate(col ="exon_UTR_id", sep = ".e", into=c("transcript.id","exon_UTR_id")) %>% mutate("exon_UTR_id" = paste0('e', exon_UTR_id))


gene.id.with.two.intron <- exon.info.all.genes %>%
  filter(`exon_UTR_id`== "exon3")
gene.with.two.intron.info <- merge(gene.id.with.two.intron, CDS.start.end.for.gene, by = "gene.id") %>%
  dplyr::select(gene.chr, gene.start, gene.end, gene.id, gene.strand.y, gene.biotype ) %>%
    arrange(gene.chr, gene.start) 
write.table(gene.with.two.intron.info,
            file = "C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/gene_with_two_intron.txt",
            quote = FALSE, sep = "\t",
            row.names = FALSE, col.names = FALSE)
```
### Use tgene_expressed_no_intron.txt and Ruggerie_whole_genome_detailed_sorted.txt 

do this on HPC with bedtool closest ignor overlaping setting

module load BEDTools

bedtools closest -io -a tgene_expressed_no_intron.txt -b gene_with_two_intron.txt -g Vv_genomeEEleaf.txt -D ref > closest_gene_gene_EE.bed

```{r}
closest_gene.no.intron_gene <- read.delim("C:/AAAStudy/PhD/Bioinformatics/Pastor/Essential_files/closest_gene_gene_EE.bed", header=FALSE) %>% 
  unique() %>%
  set_colnames(c("chr", "no.intron.start", "no.intron.end", "no.intron.id", "no.intron.strand",
                 "nearby.gene.chr", "nearby.gene.start", "nearby.gene.end", "gene.id", "nearby.gene.strand","nearby.gene.biotype", "nearby.distance")) 

#get inron information for all genes
#=========================================================================#
#as vitis vinifera doesn't have intron information from BionMart or gff, I need to create it by myself with Charlotte's method
exon.info.all.genes <- getBM(attributes=c("chromosome_name", "exon_chrom_start", "exon_chrom_end", 
                                "ensembl_exon_id","ensembl_gene_id", "strand"), mart=m) %>%
  set_colnames(c("chr","start","end","exon_UTR_id","gene.id","gene.strand")) %>%
  mutate(#chr = paste0('chr', chr),
         gene.strand = ifelse(gene.strand == 1,"+","-"))

UTR_exon.info.all.gene <- rbind(exon.info.all.genes,
                       UTR5.info,
                       UTR3.info) %>%
  arrange(chr, start, end)
# It looks like the first or last exon embl plants defined acturaly take UTR into a count as a part of it. if UTR info is provided, the intron in the UTR region can be found. otherwise, it returns intron info in the following code as typical intron, which is between two exon is a intron.
# pull out intron coordinates based on the data above
UTR_exon.all.gene.set1 <- UTR_exon.info.all.gene %>% 
  dplyr::select(chr,start,end,`exon_UTR_id`,gene.id, gene.strand) %>%
  set_colnames(c("chr","start.set1","end.set1",
                 "exon_UTR_id.set1","gene.id.set1","gene.strand.set1"))

UTR_exon.all.gene.set2 <- UTR_exon.info.all.gene[-1,] %>% 
  dplyr::select(start,end,`exon_UTR_id`,gene.id, gene.strand) %>%
  set_colnames(c("start.set2","end.set2",
                 "exon_UTR_id.set2","gene.id.set2","gene.strand.set2")) %>%
  rbind(c(0,0,NA,NA))

intron.info.all.gene <- cbind(UTR_exon.all.gene.set1, UTR_exon.all.gene.set2) %>% #intron.info = tRNA.CDS.expressed.combo - gene candidates without intron (17)
  filter(gene.id.set1 == gene.id.set2 & end.set1 < start.set2) %>%
  dplyr::select(chr, end.set1, start.set2, `exon_UTR_id.set1`, gene.id.set1, gene.strand.set1) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "intron.id","gene.id", "gene.strand")) %>%
  arrange(chr, intron.start) %>%
  mutate(intron.start = intron.start+1,
         intron.end = intron.end-1,
         intron.id = paste0(gene.id, '.intron'))

intron.num.all.gene <- sapply(as.character(unique(intron.info.all.gene$gene.id)), function(g){
  rowNb <- which(g == intron.info.all.gene$gene.id)
  strand <- intron.info.all.gene$gene.strand[rowNb]
  start <- intron.info.all.gene$intron.start[rowNb]
  order(ifelse(strand =="+", start, -start))
}) %>% unlist()

intron.info.all.gene %<>% mutate(intron.id = paste0(intron.id,".", intron.num.all.gene)) #Candidates without intron will not be included in intron.info

#=========================================================================#

#gene introns from nearby gene
intron.info.no.intron.with.nearby <- left_join(closest_gene.no.intron_gene, intron.info.all.gene, by = "gene.id" ) %>%
  dplyr::select(chr.x, intron.start, intron.end, intron.id, no.intron.id, gene.strand )
```

```{r}
# corrdinates for closest intron to intergenic for tRNA.up.intergeic 
list.gene.id.nearby <- unique(no.intron.info$gene.id)
res <- sapply(list.gene.id.nearby,function(g){
  rowNb <- which(intron.info.no.intron.with.nearby$no.intron.id == g)
  start <- intron.info.no.intron.with.nearby$intron.start[rowNb]
  or <- order(start)
  rowNb[or==1]
}) 
res <- unlist(res)

intron.one.for.stats.nearby <- intron.info.no.intron.with.nearby[res,]
intron.one.for.stats.nearby <- data_frame(chr = intron.one.for.stats.nearby$chr,
                                          start = intron.one.for.stats.nearby$intron.start,
                                          end = intron.one.for.stats.nearby$intron.end,
                                          strand = intron.one.for.stats.nearby$gene.strand,
                                          ids = intron.one.for.stats.nearby$intron.id,
                                          gene.id = intron.one.for.stats.nearby$no.intron.id,
                                          type = rep("intron_one_nearby", nrow(intron.one.for.stats.nearby)),
                                          gene.strand = intron.one.for.stats.nearby$gene.strand,
                                          length = end-start+1,
                                          sameStrand = rep("NA", nrow(intron.one.for.stats.nearby)),
                                          tRNAFirst = rep("NA", nrow(intron.one.for.stats.nearby)),
                                          tRNA.upstream = rep("NA", nrow(intron.one.for.stats.nearby)))

# range for 2nd closest intron to intergenic 
# if a gene dose not have more than one intron then the intron/intron comprison will be missing
res <- lapply(list.gene.id.nearby,function(g){
  rowNb <- which(intron.info.no.intron.with.nearby$no.intron.id == g)
  start <- intron.info.no.intron.with.nearby$intron.start[rowNb]
  or <- order(start)
  c(rowNb[or==2]) 
}) 
res <- unlist(res)

intron.two.for.stats.nearby <- intron.info.no.intron.with.nearby[res,]
intron.two.for.stats.nearby <- data_frame(chr = intron.two.for.stats.nearby$chr,
                                              start = intron.two.for.stats.nearby$intron.start,
                                              end = intron.two.for.stats.nearby$intron.end,
                                              strand = intron.two.for.stats.nearby$gene.strand,
                                              ids = intron.two.for.stats.nearby$intron.id,
                                              gene.id = intron.two.for.stats.nearby$no.intron.id,
                                              type = rep("intron_two_nearby", nrow(intron.two.for.stats.nearby)),
                                              gene.strand = intron.two.for.stats.nearby$gene.strand,
                                              length = end-start+1,
                                              sameStrand = rep("NA", nrow(intron.two.for.stats.nearby)),
                                              tRNAFirst = rep("NA", nrow(intron.two.for.stats.nearby)),
                                              tRNA.upstream = rep("NA", nrow(intron.two.for.stats.nearby)))

# combine info together for closest and 2nd closest intron
intron.one.nearby <- intron.one.for.stats.nearby %>% 
  arrange(gene.id) %>% 
  unique()%>% group_by(ids) %>% slice_min(n = 1, gene.id)%>%
    ungroup()

intron.two.nearby <- intron.two.for.stats.nearby %>% 
  arrange(gene.id) %>% 
  unique()%>% group_by(ids) %>% slice_min(n = 1, start)%>%
    ungroup()%>% group_by(ids) %>% slice_min(n = 1, gene.id)%>%
    ungroup()

# put everything together for calculate average coverage (AC)

final.stats.info.no.intron.nearby <- do.call("rbind", list(intron.one.nearby,
                                          intron.two.nearby,
                                          intergenic.info)) %>%
  arrange(gene.id)
```
#build GRange for intron and mimic intron
```{r}
# Mimic intron 1
GRange_nearby.intron1 <- intron.one.nearby %>%
  dplyr::select(chr, start, end, ids, type) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "ids", "type")) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                           ignore.strand = TRUE,
                           seqinfo = Seqinfo,
                           seqnames.field = "chr",
                           start.field = "intron.start",
                           end.field = "intron.end",
                           strand.field = NULL,
                           starts.in.df.are.0based = FALSE) 
# Mimic intron 2
GRange_nearby.intron2 <- intron.two.nearby %>%
  dplyr::select(chr, start, end, ids, type) %>%
  set_colnames(c("chr", "intron.start", "intron.end", "ids", "type")) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                           ignore.strand = TRUE,
                           seqinfo = Seqinfo,
                           seqnames.field = "chr",
                           start.field = "intron.start",
                           end.field = "intron.end",
                           strand.field = NULL,
                           starts.in.df.are.0based = FALSE)
```
## use ``Cal_Coverage()`` to look through ``bam`` files for coverage of each base
```{r, coverage of mimic.intron1  }
# calculate the AC and nZero for each sample
coverage.nearby.intron1 <- lapply (bamfiles,function(bamfile){
  Cal_Coverage(GRange_nearby.intron1, bamfile)
})
names(coverage.nearby.intron1) <- SampleName
IntronName <- names(coverage.nearby.intron1$EE1.sorted.merged.bam) # same as DicistronicName

# form a proper dataframe for all intron closest AC
AC.nearby.intron1 <- lapply(names(coverage.nearby.intron1), function(x){
  coverage.nearby.intron1[[x]] %>%
    lapply(function(i){
      data.frame(AveCov = mean(i))}) %>% 
    dplyr::bind_rows() %>%
    set_colnames(paste0(x,"_AveCov"))
}) %>%
  dplyr::bind_cols() %>%
  dplyr::mutate(ids = IntronName) %>%
  dplyr::select(ids, everything())
```

```{r, coverage of mimic.intron2 }
# calculate the AC and nZero for each sample
coverage.nearby.intron2 <- lapply (bamfiles,function(bamfile){
  Cal_Coverage(GRange_nearby.intron2, bamfile)
})
names(coverage.nearby.intron2) <- SampleName
IntronName <- names(coverage.nearby.intron2$EE1.sorted.merged.bam) # same as DicistronicName

# form a proper dataframe for mimic intron 2 AC
AC.nearby.intron2 <- lapply(names(coverage.nearby.intron2), function(x){
  coverage.nearby.intron2[[x]] %>%
    lapply(function(i){
      data.frame(AveCov = mean(i))}) %>% 
    dplyr::bind_rows() %>%
    set_colnames(paste0(x,"_AveCov"))
}) %>%
  dplyr::bind_cols() %>%
  dplyr::mutate(ids = IntronName) %>%
  dplyr::select(ids, everything())
```

```{r}
# gethering Average Coverage data for t-test
AC.nearby.final <- do.call("rbind", list(AC.intergenic,
                                  AC.nearby.intron1,
                                  AC.nearby.intron2))
```
## match the intron to each tRNA-gene combo
```{r}
# give unique id (put in id col) to intron: tRNA+gene and keep it same for intergenic
x1 <- merge(no.intron.info, intron.one.for.stats.nearby, by = "gene.id")
intron1.nearby.data <- data_frame(chr = x1$chr.y,
                                     start = x1$start,
                                     end = x1$end,
                                     ids = x1$ids,
                                     gene.id = x1$gene.id,
                                     strand = x1$gene.strand.y,
                                     id = x1$id,
                                     type = x1$type,
                                     length = x1$length.y,
                                     sameStrand = x1$sameStrand.y,
                                     tRNAFirst = x1$tRNAFirst.y,
                                     tRNA.upstream = x1$tRNA.upstream.y)

x1 <- merge(no.intron.info, intron.two.for.stats.nearby, by = "gene.id")
intron2.nearby.data <- data_frame(chr = x1$chr.y,
                                       start = x1$start,
                                       end = x1$end,
                                       ids = x1$ids,
                                       gene.id = x1$gene.id,
                                       strand = x1$gene.strand.y,
                                       id = x1$id,
                                       type = x1$type,
                                       length = x1$length.y,
                                       sameStrand = x1$sameStrand.y,
                                       tRNAFirst = x1$tRNAFirst.y,
                                       tRNA.upstream = x1$tRNA.upstream.y)

# put everything togeher
final.stats.parid.intron.nearby <- do.call("rbind", list(intron1.nearby.data,
                                           intron2.nearby.data,
                                           intergenic.data)) %>% 
  unique() %>%
  arrange(id)
```

```{r}
final.stats.test.intron.nearby <- final.stats.parid.intron.nearby %>%
  dplyr::select(chr, start, end, strand, ids, id, type, length) #%>% group_by(ids) %>% slice_min(n = 1, length)%>% ungroup()

aveCoverage.all.intron.nearby <- AC.nearby.final %>%
  left_join(final.stats.test.intron.nearby, by = "ids") %>%
  arrange(id) %>%
  unique()

aveCoverage.final.intron.nearby <- aveCoverage.all.intron.nearby %>%
  reshape2::melt(id.vars = c("ids", "chr", "start", "end", "type", "id", "strand", "length"),
       value.name = "aveCoverage", variable.name = "Sample") %>%
  mutate(Sample = gsub(x = .$Sample, pattern = "_AveCov", replacement = "")) %>%
  as_data_frame() %>%  arrange(id, Sample, type)
```
# statistical test
```{r}
# Map the tRNAs to genes
tRnaToGene.intron.nearby <- aveCoverage.final.intron.nearby %>%
  filter(grepl("t[rR][nN][aA]", ids),
         !is.na(aveCoverage)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  dplyr::select(contains("id")) %>%
  mutate(id = as.character(id)) %>%
  split(f = .$id) %>%
  lapply(function(x){
    if (nrow(x) == 1) return(x) # This removes the genes with >1 tRNA, already fixed with unique tRNA-gene combo id
  }) %>%
  bind_rows() 
```

```{r}
# create a list with 2 elements with different comparison and do the t.test
tTestResults.final.intron.nearby <- tRnaToGene.intron.nearby$ids %>% 
  # extract(1) %>% #extract 1 candidate and have a look
  lapply(function(x){
    # Get the geneid & coverage as a matrix
    combo <- filter(tRnaToGene.intron.nearby, ids ==x)$id
    cov <- filter(aveCoverage.final.intron.nearby, id == combo) %>%
      acast(Sample~type, value.var = "aveCoverage")
    
    #Initialise the output
    out <- data_frame(
      ids = character(),
      id = character(),
      comparison = character(),
      df = double(),
      V = double(),
      p = double()
    )
    
    # Compare the introns
    if (all(c("intron_twon_nearby", "intron_one_nearby") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_one_nearby"]+1),
                      log(cov[,"intron_two_nearby"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "intron_two_nearbyVsintron_one_nearby",
                     df = tTest$parameter, # degree of freedom
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    
    # Compare the intergenic regions
    if (all(c("intergenic", "intron_one_nearby") %in% colnames(cov))) {
      tTest <- t.test(log(cov[,"intron_one_nearby"]+1),
                      log(cov[,"intergenic"]+1),
                      paired = TRUE)
      out %<>%
        bind_rows(
          data_frame(ids = x,
                     id = combo,
                     comparison = "IntergenicVsintron_one_nearby",
                     df = tTest$parameter,
                     V = tTest$statistic,
                     p = tTest$p.value)
        )
    }
    out
    
  }) %>%
  bind_rows() %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         FDR = p.adjust(p, "fdr")) %>%
  arrange(p) %>%
  split(f = .$comparison)
```
## t.test output
```{r two way filtering}
# for FDR
intergeic.sign.final.intron.nearby <- tTestResults.final.intron.nearby$IntergenicVsintron_one_nearby %>% 
  filter(FDR < 0.05, V < 0) 
intron.not.sign.final.intron.nearby <- tTestResults.final.intron.nearby$intron_one_nearbyVsintron_one_nearby %>% 
  filter((FDR < 0.05 & V > 0) | FDR >=0.05)
final.sign.intron.nearby <- intersect(intron.not.sign.final.intron.nearby$id,intergeic.sign.final.intron.nearby$id)
#-----------------------------------------------------------------#
#for adjP (optional)
#intergeic.sign.final <- tTestResults.final$IntergenicVsIntron1 %>% 
 # filter(adjP < 0.05, V < 0)
#intron.not.sign.final <- tTestResults.final$Intron2VsIntron1 %>% 
 # filter((adjP < 0.05 & V > 0) | adjP >=0.05) 
#final.sign.adjP <- intersect(intron.not.sign.final$id,intergeic.sign.final$id) 
```
###filter ids that overlapped with two methods
```{r}
final.sign.no.intron.overlap <- intersect(final.sign.no.intron,final.sign.intron.nearby)
```
## assess continuous coverage for candidates with no intron that pass the t.test with both methods
```{r}
#filter no zero coverage in intergenic region and pass t-test with both methods
coverage.list.final.no.intron <- nZero.intergenic %>%
  merge(final.stats.parid.no.intron, by = "ids") %>%
 filter(id %in% final.sign.no.intron.overlap) %>%
  mutate(continu.cov = rowSums(dplyr::select(., contains("nZero"))) == 0)

# make all coverage data addable for each sample and assess the continious Cov for combined coverage
keptIntergenic.no.intron <- coverage.list.final.no.intron$ids
coverage.samples.final.no.intron <- coverage.samples[names(coverage.samples) %in% keptIntergenic.no.intron] 
combined.nZero.no.intron <- coverage.samples.final.no.intron %>% 
  lapply(function(intergenic){
    sum(rowSums(intergenic)==0)
  }) %>% unlist() %>% as.data.frame() %>% rownames_to_column() %>%
  set_colnames(c("ids","Combined.nZero"))

continuous.coverage.final.no.intron <- left_join(coverage.list.final.no.intron,combined.nZero.no.intron, by = "ids") %>%
  mutate(Combined.nZero = Combined.nZero == 0) %>%
  setnames("Combined.nZero", "combined.continu.cov")
```
# export results
```{r}
write.table(continuous.coverage.final.no.intron,
            file = "C:/AAAStudy/PhD/Bioinformatics/Pastor/result/EE_Berry_with_no_intron.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
```
#put results from three types(two and more introns, one intron, no intron) together
```{r}
continuous.coverage.final.all <- rbind(continuous.coverage.final, continuous.coverage.final.one.intron, continuous.coverage.final.no.intron) %>% filter(combined.continu.cov == TRUE)
```
#estimate if the tRNA is in UTR 
```{r}
# combine continuous.coverage.final.all with tRNA coordinates
Dicistronic.all.tRNA <- left_join(continuous.coverage.final.all,tRNA.CDS.expressed.combo, by ="id") %>%
   dplyr::select(id, chr.x, start, end, gene.id.x, gene.start, gene.end, gene.strand, tRNA.id, tRNA.start, tRNA.end, tRNA.strand, tRNA.upstream.x, tRNAFirst.x, interval.length, continu.cov, combined.continu.cov) %>%
  set_colnames(c("id", "chr", "start", "end", "gene.id", "gene.start", "gene.end", "gene.strand", "tRNA.id", "tRNA.start", "tRNA.end", "tRNA.strand", "tRNA.upstream", "tRNAFirst", "interval.length", "continu.cov", "combined.continu.cov"))
#bind candidates with UTR information
Dicistronic.UTR5.info <- UTR5.info %>% filter(gene.id %in% Dicistronic.all.tRNA$gene.id) 
Dicistronic.UTR3.info <- UTR3.info %>% filter(gene.id %in% Dicistronic.all.tRNA$gene.id) 
#Remember that until now the gene start and end in dicistronic information are CDS start end coordinate, not the real gene start/end coordinate, so I will make real gene coordinate.
Dicistronic.gene.info <- left_join(Dicistronic.UTR5.info, Dicistronic.UTR3.info, by = "gene.id")
Dicistronic.gene.startend <- Dicistronic.gene.info %>% mutate(start = ifelse(gene.strand.x == '+', start.x,
                                                                             ifelse(gene.strand.x == '-', start.y, start.x)),
                                                                end = ifelse(gene.strand.x == '+', end.y,
                                                                             ifelse(gene.strand.x == '-', end.x, end.y)),
                                                              gene.length = end - start + 1) %>%
  dplyr::select(chr.x, gene.id, start, end, gene.strand.y, gene.length) %>%
  group_by(gene.id) %>% slice_max(n = 1, gene.length)%>%ungroup() %>% 
  unique()

gene.info <- getBM(attributes=c("chromosome_name", "start_position", "end_position",
                                "ensembl_gene_id", "strand", "gene_biotype"), mart=m)  %>%
  set_colnames(c("gene.chr", "gene.start", "gene.end", "gene.id", "gene.strand", "gene.biotype")) %>%
  mutate(#gene.chr = paste0('chr', gene.chr),
         gene.strand = ifelse(gene.strand == 1,"+","-")) %>%  # make it consistant with other data for strand symbol and Chr names, if the format alread matched, this line of code needs to set as comment 
  arrange(gene.chr, gene.start)

gene.info.sorted <- gene.info %>%
  filter(gene.biotype == "protein_coding") %>% # keep the type of annotation that you are interested to explore
  arrange(gene.chr, gene.start) 
Dicistronic.gene <- gene.info.sorted %>% filter(gene.id %in% continuous.coverage.final.all$gene.id) %>% unique()

# estimate if tRNA overlaps with UTR
Dicistronic.tRNA.gene.coordinate <- left_join(Dicistronic.all.tRNA, Dicistronic.gene, by = "gene.id") %>%
  dplyr::select(id, chr, start, end, gene.id, gene.start.y, gene.end.y, gene.strand.x, tRNA.id, tRNA.start, tRNA.end, tRNA.strand, tRNA.upstream, tRNAFirst, interval.length, continu.cov, combined.continu.cov) %>%
  set_colnames(c("id", "chr", "start", "end", "gene.id", "gene.start", "gene.end", "gene.strand", "tRNA.id", "tRNA.start", "tRNA.end", "tRNA.strand", "tRNA.upstream", "tRNAFirst", "interval.length", "continu.cov", "combined.continu.cov")) %>%  mutate(tRNA.overlap.UTR = ifelse(tRNAFirst == 'TRUE' & gene.start < tRNA.end, TRUE,
                                    ifelse(tRNAFirst == 'FALSE'& gene.end > tRNA.start, "TRUE","FALSE" ))) %>%
  dplyr::select(id, chr, start, end, gene.id, gene.start, gene.end, gene.strand, tRNA.id, tRNA.start, tRNA.end, tRNA.strand, tRNA.upstream, tRNAFirst, interval.length, continu.cov, combined.continu.cov, tRNA.overlap.UTR)
```
# export results
```{r}
write.table(Dicistronic.tRNA.gene.coordinate,
            file = "C:/AAAStudy/PhD/Bioinformatics/Pastor/result/EE_Berry_Final_Result.xlsx",
            quote = FALSE, sep = "\t", row.names = FALSE)
```
